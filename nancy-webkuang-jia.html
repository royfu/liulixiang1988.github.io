<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Nancy Web框架</title>
  <meta name="author" content="理想">



  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href="./favicon.png" rel="icon">
  <link href="./theme/css/main.css" media="screen, projection"
        rel="stylesheet" type="text/css">
  <script src="./theme/js/modernizr-2.0.js"></script>
  <script src="./theme/js/ender.js"></script>
  <script src="./theme/js/octopress.js" type="text/javascript"></script>

  <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
</head>

<body>
  <header role="banner"><hgroup>
  <h1><a href="./">理想国</a></h1>
</hgroup></header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
</ul>


<form action="//google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:." />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>

<ul class="main-navigation">
    <li >
    <a href="./category/android.html">Android</a>
    </li>
    <li >
    <a href="./category/dotnet.html">Dotnet</a>
    </li>
    <li class="active">
    <a href="./category/net.html">.net</a>
    </li>
    <li >
    <a href="./category/python.html">Python</a>
    </li>
    <li >
    <a href="./category/sheng-huo.html">生活</a>
    </li>
</ul></nav>
  <div id="main">
    <div id="content">
<div>
  <article class="hentry" role="article">
<header>
      <h1 class="entry-title">Nancy Web框架</h1>
      <p class="meta"><time datetime="2014-09-12T23:39:00" pubdate>五 12 九月 2014</time></p>
</header>

  <div class="entry-content"><p>[TOC]</p>
<h1>Nancy框架</h1>
<h2>一、创建第一个Nancy应用</h2>
<ol>
<li>安装<a href="http://visualstudiogallery.msdn.microsoft.com/f1e29f61-4dff-4b1e-a14b-6bd0d307611a">Nancy项目模板</a></li>
<li>创建<code>Nancy Empty Web Application with ASP.NET Hosting</code></li>
<li>添加<code>Nancy module</code>,它是一个标准C#类，通过添加下面几行代码定义了web应用的路由处理方法。</li>
<li>编译并运行。</li>
</ol>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">HelloModule</span> <span class="o">:</span> <span class="n">NancyModule</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="n">HelloModule</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Get</span><span class="p">[</span><span class="s">&quot;/&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="s">&quot;Hello World&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h2>二、探索Nancy的module</h2>
<p>Module继承自<code>NancyModule</code>类。Module是必不可少的.它不仅定义了路由，还提供了许多其他信息，比如请求、上下文、构造响应的辅助方法、视图渲染等等。</p>
<h3>1. 模块能够在全局被发现</h3>
<p>可以在任意地方定义module，比如外部的dll等，这为代码的复用带来很大的方便。不用担心效率问题，扫描module只在程序启动时发生。</p>
<h3>2. 使用模块为路由创建一个根</h3>
<p>类似命名空间的概念，在创建构造方法时传给base一个名称。</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">ResourceModule</span> <span class="o">:</span> <span class="n">NancyModule</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="n">ResourceModule</span><span class="p">()</span> <span class="o">:</span> <span class="n">base</span><span class="p">(</span><span class="s">&quot;/products&quot;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// would capture routes to /products/list sent as a GET request</span>
        <span class="n">Get</span><span class="p">[</span><span class="s">&quot;/list&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">&quot;The list of products&quot;</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h2>三、定义路由</h2>
<p>路由是在module的构造方法中定义的。为了定义一个路由，你需要声明<code>方法</code>+<code>模式</code>+<code>动作</code>+(可选)<code>条件</code></p>
<p>比如：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">ProductsModule</span> <span class="o">:</span> <span class="n">NancyModule</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="n">ProductsModule</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Get</span><span class="p">[</span><span class="s">&quot;/products/{id}&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_</span> <span class="o">=&gt;</span>
        <span class="p">{</span>
            <span class="c1">//do something</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>或者异步</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">ProductsModule</span> <span class="o">:</span> <span class="n">NancyModule</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="n">ProductsModule</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Get</span><span class="p">[</span><span class="s">&quot;/products/{id}&quot;</span><span class="p">,</span> <span class="n">runAsync</span><span class="o">:</span> <span class="nb">true</span><span class="p">]</span> <span class="o">=</span> <span class="n">async</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="p">{</span>
            <span class="c1">//do something long and tedious</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3>1. 方法</h3>
<p>支持HTTP常见方法：<code>DELETE</code>, <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code></p>
<h3>2. 模式</h3>
<p>模式能够自定义，Nancy提供了一些常用的：</p>
<ol>
<li>字面量 - <code>/some/literal/segments</code></li>
<li>捕获片段 - <code>/{name}</code>，获取URL的片段，并传给路由的Action</li>
<li>捕获可选片段 - <code>/{name?}</code>，添加了一个问号，片段就是可选的了</li>
<li>捕获可选/默认片段 - <code>/{name?default}</code></li>
<li>正则片段 - <code>/(?&lt;age&gt;[\d]{1,2})</code>，使用命名捕获组来捕获片段，如果不需要捕获，使用非捕获组，比如<code>(?:regex-goes-here)</code></li>
<li>贪心片段 - <code>/{name*}</code>，从/处开始捕获</li>
<li>贪心正则捕获 - <code>^(?&lt;name&gt;[a-z]{3, 10}(?:/{1})(?&lt;action&gt;[a-z]{5, 10}))$</code></li>
<li>多个捕获片段 - <code>/{file}.{extension}</code>或者<code>/{file}.ext</code></li>
</ol>
<h3>3. 模式的优先级</h3>
<h3>4. 动作</h3>
<p>动作时一个lambda表达式<code>Func&lt;dynamic, dynamic&gt;</code>，输入时<code>DynamicDictionary</code>，详见<a href="https://github.com/NancyFx/Nancy/wiki/Taking-a-look-at-the-DynamicDictionary">此处</a>.</p>
<p>响应可以使任意的model，最终的结果会被<a href="https://github.com/NancyFx/Nancy/wiki/Content-Negotiation">Content Negotiation</a>处理。但是如果返回值是<code>Response</code>类型，则原样返回。</p>
<p><code>Response</code>对象有几个隐形转换操作：
1. <code>int</code>变为Http的状态
2. <code>HttpStatusCode</code>枚举值
3. <code>string</code>直接是相应的body
4. <code>Action&lt;Stream&gt;</code>则写道response stream中</p>
<h3>5. 条件</h3>
<p>路由条件用来过滤（比如登录非登录）。使用<code>Func&lt;NancyContext, bool&gt;</code>的lambda表达式定义.</p>
<div class="highlight"><pre><span class="n">Post</span><span class="p">[</span><span class="s">&quot;/login&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">ctx</span><span class="p">.</span><span class="n">Request</span><span class="p">.</span><span class="n">Form</span><span class="p">.</span><span class="n">remember</span><span class="p">]</span> <span class="o">=</span> <span class="n">_</span> <span class="o">=&gt;</span> 
<span class="p">{</span>
     <span class="k">return</span> <span class="s">&quot;Handling code when remember is true!&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Post</span><span class="p">[</span><span class="s">&quot;/login&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="n">ctx</span><span class="p">.</span><span class="n">Request</span><span class="p">.</span><span class="n">Form</span><span class="p">.</span><span class="n">remember</span><span class="p">]</span> <span class="o">=</span> <span class="n">_</span> <span class="o">=&gt;</span> 
<span class="p">{</span>
     <span class="k">return</span> <span class="s">&quot;Handling code when remember is false!&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h3>6. 路由片段约束</h3>
<div class="highlight"><pre><span class="n">Get</span><span class="p">[</span><span class="s">&quot;/intConstraint/{value:int}&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_</span> <span class="o">=&gt;</span> <span class="s">&quot;Value &quot;</span> <span class="o">+</span> <span class="n">_</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="s">&quot; is an integer.&quot;</span><span class="p">;</span>
</pre></div>


<p>只有为int的才会匹配。</p>
<p>约束：
- <code>int</code>
- <code>decimal</code>
- <code>guid</code>
- <code>bool</code>
- <code>alpha</code>
- <code>datetime</code>
- <code>datetime(format)</code>
- <code>min(minimum)</code>
- <code>max(maximum)</code>
- <code>range(minimum, maximum)</code>
- <code>minlength(length)</code>
- <code>maxlength(length)</code>
- <code>length(minimum, maximum)</code></p>
<h4>6.1 自定义约束</h4>
<p>实现<code>IRouteSegmentConstraint</code>接口，或者继承自
- <code>RouteSegmentConstraintBase&lt;T&gt;</code> - Base class for a named constraint.
- <code>ParameterizedRouteSegmentConstraintBase&lt;T&gt;</code> - Base class for a named constraint that accepts arguments.</p>
<h5>例子</h5>
<p>一个email约束</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">EmailRouteSegmentConstraint</span> <span class="o">:</span> <span class="n">RouteSegmentConstraintBase</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="n">override</span> <span class="n">string</span> <span class="n">Name</span>
    <span class="p">{</span>
        <span class="n">get</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;email&quot;</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">protected</span> <span class="n">override</span> <span class="kt">bool</span> <span class="n">TryMatch</span><span class="p">(</span><span class="n">string</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">string</span> <span class="n">segment</span><span class="p">,</span> <span class="n">out</span> <span class="n">string</span> <span class="n">matchedValue</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">segment</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="s">&quot;@&quot;</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">matchedValue</span> <span class="o">=</span> <span class="n">segment</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">matchedValue</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>用法</p>
<div class="highlight"><pre><span class="n">Get</span><span class="p">[</span><span class="s">&quot;/profile/{value:email}&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_</span> <span class="o">=&gt;</span> <span class="s">&quot;Value &quot;</span> <span class="o">+</span> <span class="n">_</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="s">&quot; is an e-mail address.&quot;</span><span class="p">;</span>
</pre></div>


<h3>7. 选择去调用路由的秘诀</h3>
<p>一个请求有时符合多个模式，此时记住：
1. module的顺序在启动时不定
2. 同一module中的路由是按顺序来的
3. 多个匹配中，得分最高的匹配
4. 得分相同的匹配按照启动时的顺序匹配</p>
<h3>8. 疯狂的路由</h3>
<p>一些可能的用法：</p>
<div class="highlight"><pre><span class="c1">// would capture routes like /hello/nancy sent as a GET request</span>
<span class="n">Get</span><span class="p">[</span><span class="s">&quot;/hello/{name}&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Hello &quot;</span> <span class="o">+</span> <span class="n">parameters</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// would capture routes like /favoriteNumber/1234, but not /favoriteNumber/asdf as a GET request</span>
<span class="n">Get</span><span class="p">[</span><span class="s">&quot;/favoriteNumber/{value:int}&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;So your favorite number is &quot;</span> <span class="o">+</span> <span class="n">parameters</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="s">&quot;?&quot;</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// would capture routes like /products/1034 sent as a DELETE request</span>
<span class="n">Delete</span><span class="p">[</span><span class="s">@&quot;/products/(?&lt;id&gt;[\d]{1,7})&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">200</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// would capture routes like /users/192/add/moderator sent as a POST request</span>
<span class="n">Post</span><span class="p">[</span><span class="s">&quot;/users/{id}/add/{category}&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">HttpStatusCode</span><span class="p">.</span><span class="n">OK</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<h2>四、自定义路由</h2>
<p>http://www.philliphaydon.com/2013/04/nancyfx-implementing-your-own-routing/</p>
<h2>五、异步</h2>
<h3>1. 语法</h3>
<p>Before/After管道、主路由委托都可以使用async.语法绝大部分与同步代码一致，但需要注意下面的变化：</p>
<ul>
<li>before/after钩子接受两个参数，context和cancellation token(取消令牌)，而不仅仅是context</li>
<li>路由定义有一个附加的bool参数，并且委托接受两个参数，一个捕获的参数，另一个cancellation token.</li>
</ul>
<h3>2 语法例子</h3>
<div class="highlight"><pre><span class="n">public</span> <span class="nf">MainModule</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Before</span> <span class="o">+=</span> <span class="n">async</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="p">{</span>
            <span class="n">this</span><span class="p">.</span><span class="n">AddToLog</span><span class="p">(</span><span class="s">&quot;Before Hook Delay</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
            <span class="n">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>

            <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
        <span class="p">};</span>

    <span class="n">After</span> <span class="o">+=</span> <span class="n">async</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="p">{</span>
            <span class="n">this</span><span class="p">.</span><span class="n">AddToLog</span><span class="p">(</span><span class="s">&quot;After Hook Delay</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
            <span class="n">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
            <span class="n">this</span><span class="p">.</span><span class="n">AddToLog</span><span class="p">(</span><span class="s">&quot;After Hook Complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

            <span class="n">ctx</span><span class="p">.</span><span class="n">Response</span> <span class="o">=</span> <span class="n">this</span><span class="p">.</span><span class="n">GetLog</span><span class="p">();</span>
        <span class="p">};</span>

    <span class="n">Get</span><span class="p">[</span><span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="nb">true</span><span class="p">]</span> <span class="o">=</span> <span class="n">async</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="p">{</span>
            <span class="n">this</span><span class="p">.</span><span class="n">AddToLog</span><span class="p">(</span><span class="s">&quot;Delay 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
            <span class="n">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

            <span class="n">this</span><span class="p">.</span><span class="n">AddToLog</span><span class="p">(</span><span class="s">&quot;Delay 2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
            <span class="n">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

            <span class="n">this</span><span class="p">.</span><span class="n">AddToLog</span><span class="p">(</span><span class="s">&quot;Executing async http client</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
            <span class="n">var</span> <span class="n">client</span> <span class="o">=</span> <span class="n">new</span> <span class="n">HttpClient</span><span class="p">();</span>
            <span class="n">var</span> <span class="n">res</span> <span class="o">=</span> <span class="n">await</span> <span class="n">client</span><span class="p">.</span><span class="n">GetAsync</span><span class="p">(</span><span class="s">&quot;http://nancyfx.org&quot;</span><span class="p">);</span>
            <span class="n">var</span> <span class="n">content</span> <span class="o">=</span> <span class="n">await</span> <span class="n">res</span><span class="p">.</span><span class="n">Content</span><span class="p">.</span><span class="n">ReadAsStringAsync</span><span class="p">();</span>

            <span class="n">this</span><span class="p">.</span><span class="n">AddToLog</span><span class="p">(</span><span class="s">&quot;Response: &quot;</span> <span class="o">+</span> <span class="n">content</span><span class="p">.</span><span class="n">Split</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">Response</span><span class="p">)</span><span class="n">this</span><span class="p">.</span><span class="n">GetLog</span><span class="p">();</span>
        <span class="p">};</span>
<span class="p">}</span>
</pre></div>


<h2>六、查看DynamicDictionary</h2>
<p><code>DynamicDictionary</code>类似字典，但功能更多.从请求中获取的值都保存到它里面。可以使用属性或者index来使用捕获的值。</p>
<div class="highlight"><pre><span class="n">Get</span><span class="p">[</span><span class="s">&quot;/hello/{name}&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Hello &quot;</span> <span class="o">+</span> <span class="n">parameters</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Get</span><span class="p">[</span><span class="s">&quot;/goodbye/{name}&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Goodbye &quot;</span> <span class="o">+</span> <span class="n">parameters</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


<p>存储的值可以显示或者隐式的转换为基础类型或者特殊属性.使用<code>HasValue</code>决定是否被赋值。值已经实现了<code>IEquatable&lt;&gt;</code>和<code>IConvertible</code>接口。</p>
<h2>七、module的before/after钩子</h2>
<p>除了为特定的路由定义处理程序,module还可以拦截匹配某个路由的请求,请求前后都能做到。重要的是要理解,只有传入的请求匹配模块的路由之一，这些拦截器才会被调用。</p>
<h3>1. 在路由被调用前拦截请求</h3>
<p>Before拦截器能让你修改请求，甚至可以通过返回一个response来放弃请求。</p>
<div class="highlight"><pre><span class="n">Before</span> <span class="o">+=</span> <span class="n">ctx</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="n">null</span> <span class="n">or</span> <span class="n">a</span> <span class="n">Response</span> <span class="n">object</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>定义Before拦截器的语法与定义路由有些不同。因为它是定义在module上，被所有路由调用，所以不需要匹配模式。</p>
<p>传给拦截器的是当前请求的NancyContext实例。</p>
<p>最后的不同就是拦截器的返回值，如果返回<code>null</code>，拦截器将主动权转给路由；如果返回<code>Response</code>对象，则路由不起作用。</p>
<h3>2. After拦截器</h3>
<p>与定义Before烂机器相同，但是没有返回值。</p>
<div class="highlight"><pre><span class="n">After</span> <span class="o">+=</span> <span class="n">ctx</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// Modify ctx.Response</span>
<span class="p">};</span>
</pre></div>


<p>Before拦截器可以修改Request，相应的，After拦截器可以修改Response。</p>
<h2>八、Application的Before,After和OnError管道</h2>
<p>应用管道能在所有的路由上执行，是全局性的。</p>
<h3>1.Before拦截</h3>
<p>应用级的<code>Before</code>钩子通过<code>Func&lt;NancyContext, Response&gt;</code>函数定义：</p>
<div class="highlight"><pre><span class="n">pipelines</span><span class="p">.</span><span class="n">BeforeRequest</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="n">null</span> <span class="n">or</span> <span class="n">a</span> <span class="n">Response</span> <span class="n">object</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>异步版本的：</p>
<div class="highlight"><pre><span class="n">pipelines</span><span class="p">.</span><span class="n">BeforeRequest</span> <span class="o">+=</span> <span class="n">async</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="n">null</span> <span class="n">or</span> <span class="n">a</span> <span class="n">Response</span> <span class="n">object</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<h3>2. After拦截</h3>
<p>After拦截器通过`Action<NancyContext>定义：</p>
<div class="highlight"><pre><span class="n">pipelines</span><span class="p">.</span><span class="n">AfterRequest</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// Modify ctx.Response</span>
<span class="p">};</span>
</pre></div>


<h3>3. 错误拦截器</h3>
<p><code>OnError</code>拦截器用来拦截路由发生的错误。通过它可以获取<code>NancyContext</code>和发生的异常。</p>
<p><code>OnError</code>拦截器通过<code>Func&lt;NancyContext, Exception, Response&gt;</code>函数定义：</p>
<div class="highlight"><pre><span class="n">pipelines</span><span class="p">.</span><span class="n">OnError</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p><strong>System.AggregateExceptions在OnError管道中的注意事项：</strong></p>
<p>路由是通过许多嵌套的Task(<code>System.Threading.Tasks.Task</code>)来执行的。如果那个任务出现了问题，异常会被包装到<code>System.AggregateException</code>。<code>System.AggregateException</code>可以持有任意个异常。</p>
<p>如果只有一个异常，Nancy会解包异常并且交给<code>OnError</code>管道。如果发生多个异常，Nancy会使用<code>System.AggregateException</code>，以避免吞异常。</p>
<h3>4. 构建自己的钩子</h3>
<p>在<a href="https://github.com/NancyFx/Nancy/wiki/Bootstrapper">Bootstrapper</a>中创建系统级的钩子.可以在<code>ApplicationStartup</code>或者<code>RequestStartup</code>方法中定义它们。这是因为也许你需要在钩子中使用容器中的一些东西。两个方法的不同之处在于范围不同。</p>
<div class="highlight"><pre><span class="n">protected</span> <span class="n">override</span> <span class="kt">void</span> <span class="nf">ApplicationStartup</span><span class="p">(</span><span class="n">TinyIoCContainer</span> <span class="n">container</span><span class="p">,</span> <span class="n">IPipelines</span> <span class="n">pipelines</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="n">protected</span> <span class="n">override</span> <span class="kt">void</span> <span class="nf">RequestStartup</span><span class="p">(</span><span class="n">TinyIoCContainer</span> <span class="n">requestContainer</span><span class="p">,</span> <span class="n">IPipelines</span> <span class="n">pipelines</span><span class="p">,</span> <span class="n">NancyContext</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>


<p>通过使用<code>pipelines</code>中适当的属性来创建钩子。它允许你获取<code>BeforeRequest</code>, <code>AfterRequest</code>和<code>OnError</code>属性。</p>
<h2>九、模型绑定</h2>
<p>发送数据给Nancy可以有多种方法，比如Query String, 路由捕获参数、请求体request body。手工处理这些不同的方法也可以，但是还有一种方法就是统一处理，绑定到<code>model</code>。</p>
<p>Nancy只用一行代码就能处理上述的所有情况，并且能接受<code>JSON</code>和<code>XML</code>形式的请求。</p>
<p>也可以扩展Nancy的模型绑定。</p>
<p>Nancy的模型绑定在<code>NancyModule</code>中被定义为一个单独的扩展方法。该扩展在<code>Nancy.ModelBinding</code>命名空间里，并且添加了Bind()和BindTo()方法</p>
<div class="highlight"><pre><span class="nb">Foo</span> <span class="n">f</span> <span class="o">=</span> <span class="nx">this.Bind</span><span class="p">();</span>

<span class="kd">var</span> <span class="n">f</span> <span class="o">=</span> <span class="nx">this.Bind</span><span class="o">&lt;</span><span class="nb">Foo</span><span class="o">&gt;</span><span class="p">();</span>

<span class="kd">var</span> <span class="n">f</span> <span class="o">=</span> <span class="nx">this.BindTo</span><span class="p">(</span><span class="nx">instance</span><span class="p">);</span>
</pre></div>


<p>上面3个有着相同的功能，他们提供了做同一事物的不同方法。前两个使用Bind()重载来创建<code>Foo</code>类型的实例，并且绑定；BindTo()则绑定到现有实例。</p>
<h3>1. 屏蔽不想要的信息</h3>
<div class="highlight"><pre><span class="kd">var</span> <span class="n">f</span> <span class="o">=</span> <span class="nx">this.Bind</span><span class="o">&lt;</span><span class="nb">Foo</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span> <span class="o">=&gt;</span> <span class="nx">f.id</span><span class="p">,</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="nx">f.creator</span><span class="p">,</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="nx">f.createddate</span><span class="p">);</span>
</pre></div>


<p>或者</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="n">f</span> <span class="o">=</span> <span class="nx">this.Bind</span><span class="o">&lt;</span><span class="nb">Foo</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;creator&quot;</span><span class="p">,</span> <span class="s2">&quot;createddate&quot;</span><span class="p">);</span>
</pre></div>


<p>当绑定到到arrary, list或者ienumerable时，屏蔽的是序列中的元素。</p>
<h3>2. 绑定配置</h3>
<p>使用<code>BindingConfig</code>实例来修改model binder的默认行为。</p>
<p>下面是<code>BindingConfig</code>提供的一些配置项：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认</th>
</tr>
</thead>
<tbody>
<tr>
<td>BodyOnly</td>
<td>是否只绑定request body。这种情况下，request和context参数都不会被绑定。如果没有body并且没有选项，那么绑定就不会放生</td>
<td>false</td>
</tr>
<tr>
<td>IgnoreErrors</td>
<td>是否忽略绑定错误并且继续下一个属性</td>
<td>false</td>
</tr>
<tr>
<td>Overwrite</td>
<td>丙丁是否可以覆盖没有默认值的属性</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>不准Overwrite还有一个快捷方法：<code>BindingConfig.NoOverwrite</code></p>
<h3>3. 反序列化rich request body payloads(负载)</h3>
<p>有时你像在请求中发送结构化的数据，比如<code>JSON</code>或者<code>XML</code>，并且绑定到模型。模型绑定器支持这种反序列化。</p>
<p>Nancy支持两种反序列化：JSON和XML。绑定器根据Http的<code>Content-type</code>头来决定使用哪一种反序列化。</p>
<p>默认使用JSON反序列化来处理<code>application/json</code>, <code>text/json</code>和<code>application/vnd....+json</code>。同样的使用XML反序列化来处理<code>application/xml</code>, <code>text/xml</code>和<code>application/vnd....+xml</code></p>
<p>对于其他模型绑定器，你可以使用自己的反序列化，并且Nancy会自动检测他们，任何用户定义的绑定器的优先级都高于内建的。
<strong>注意：</strong>如果你使用Nancy.Json.JsonSetting.MaxJsonLength Exceeded错误，那是因为你的payloads太高了，在Bootstrapper中更改限制：<code>ApplicationStartup</code>中设置<code>Nancy.Json.JsonSettings.MaxJsonLength=int.MaxValue</code></p>
<h3>4. 模型绑定Checkbox</h3>
<p>要绑定复选框到bool值，确定设置<code>value=true</code>：</p>
<div class="highlight"><pre><span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;checkbox&quot;</span> <span class="na">name=</span><span class="s">&quot;rememberMe&quot;</span> <span class="na">value=</span><span class="s">&quot;true&quot;</span><span class="nt">/&gt;</span>
</pre></div>


<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">LoginModel</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="kt">bool</span> <span class="n">RememberMe</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="n">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3>5. 绑定到list</h3>
<h4>5.1 绑定arrary到单独的对象</h4>
<p>如果有一个form:</p>
<div class="highlight"><pre><span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">&quot;/ArrayOnObject&quot;</span> <span class="na">method=</span><span class="s">&quot;post&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;text&quot;</span> <span class="na">name=</span><span class="s">&quot;Tags&quot;</span> <span class="na">value=</span><span class="s">&quot;Tag1,Tag2,Tag3&quot;</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;text&quot;</span> <span class="na">name=</span><span class="s">&quot;Ints&quot;</span> <span class="na">value=</span><span class="s">&quot;1,2,3,4,4,5,6,3,2,21,1&quot;</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;submit&quot;</span> <span class="na">value=</span><span class="s">&quot;Submit&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</pre></div>


<p>而且有一个类：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">Posts</span>
<span class="p">{</span>
  <span class="n">public</span> <span class="n">string</span><span class="p">[]</span> <span class="n">Tags</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="n">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">public</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">Ints</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="n">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>使用一个简单的语句：</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="n">listOfPosts</span> <span class="o">=</span> <span class="nx">this.Bind</span><span class="o">&lt;</span><span class="nx">Posts</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>


<h4>5.2 绑定到对象的list</h4>
<div class="highlight"><pre><span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">&quot;/SimpleListDemo&quot;</span> <span class="na">method=</span><span class="s">&quot;post&quot;</span><span class="nt">&gt;</span>
      User 1:<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;text&quot;</span> <span class="na">name=</span><span class="s">&quot;Name[0]&quot;</span> <span class="na">value=</span><span class="s">&quot;thecodejunkie&quot;</span> <span class="nt">/&gt;</span> 
      Commits <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;text&quot;</span> <span class="na">name=</span><span class="s">&quot;Commits[0]&quot;</span> <span class="na">value=</span><span class="s">&quot;1068&quot;</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;br</span> <span class="nt">/&gt;</span>
      User 2:<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;text&quot;</span> <span class="na">name=</span><span class="s">&quot;Name[1]&quot;</span> <span class="na">value=</span><span class="s">&quot;grumpydev&quot;</span> <span class="nt">/&gt;</span>  
      Commits <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;text&quot;</span> <span class="na">name=</span><span class="s">&quot;Commits[1]&quot;</span> <span class="na">value=</span><span class="s">&quot;1049&quot;</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;br</span> <span class="nt">/&gt;</span>
      User 3:<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;text&quot;</span> <span class="na">name=</span><span class="s">&quot;Name[2]&quot;</span> <span class="na">value=</span><span class="s">&quot;jchannon&quot;</span> <span class="nt">/&gt;</span>  
      Commits <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;text&quot;</span> <span class="na">name=</span><span class="s">&quot;Commits[2]&quot;</span> <span class="na">value=</span><span class="s">&quot;109&quot;</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;br</span> <span class="nt">/&gt;</span>
      User 4:<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;text&quot;</span> <span class="na">name=</span><span class="s">&quot;Name[3]&quot;</span> <span class="na">value=</span><span class="s">&quot;prabirshrestha&quot;</span> <span class="nt">/&gt;</span>  
      Commits <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;text&quot;</span> <span class="na">name=</span><span class="s">&quot;Commits[3]&quot;</span> <span class="na">value=</span><span class="s">&quot;75&quot;</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;br</span> <span class="nt">/&gt;</span>
      User 5:<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;text&quot;</span> <span class="na">name=</span><span class="s">&quot;Name[4]&quot;</span> <span class="na">value=</span><span class="s">&quot;phillip-haydon&quot;</span> <span class="nt">/&gt;</span>  
      Commits <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;text&quot;</span> <span class="na">name=</span><span class="s">&quot;Commits[4]&quot;</span> <span class="na">value=</span><span class="s">&quot;40&quot;</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;br</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;submit&quot;</span> <span class="na">value=</span><span class="s">&quot;Test the binding thingy&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</pre></div>


<p>可以使用<code>this.Bind&lt;List&lt;User&gt;&gt;();</code>来绑定对象列表：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">User</span>
<span class="p">{</span>
   <span class="n">public</span> <span class="n">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="n">set</span><span class="p">;</span> <span class="p">}</span>
   <span class="n">public</span> <span class="kt">int</span> <span class="n">Commits</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="n">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4>5.3 HTML form中的List分隔符</h4>
<p>两种分隔符</p>
<ul>
<li>下划线(<code>Name_1</code>, <code>Name_2</code>等)</li>
<li>括号(<code>Name[1]</code>, <code>Name[2]</code>等)</li>
</ul>
<h2>十、Bootstrapper</h2>
<p>bootstrapper负责自动发现模型、自定义模型绑定、依赖等等。可以被替换掉。</p>
<h3>1. 简单的修改bootstrapper</h3>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">CustomBootstrapper</span> <span class="o">:</span> <span class="n">DefaultNancyBootstrapper</span>
<span class="p">{</span>
    <span class="n">protected</span> <span class="n">override</span> <span class="kt">void</span> <span class="n">ApplicationStartup</span><span class="p">(</span><span class="n">TinyIoCContainer</span> <span class="n">container</span><span class="p">,</span> <span class="n">IPipelines</span> <span class="n">pipelines</span><span class="p">)</span>
    <span class="p">{</span>
         <span class="c1">// your customization goes here</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3>2. 找到合适的bootstrapper</h3>
<p>应用启动时，它会寻找自定义的bootstrap，如果没有找到，则使用<code>DefaultNancyBootstrap</code>。每个应用只能有<strong>一个</strong>bootstrapper. 如果有多个，则Nancy寻找最底层的bootstrapper。</p>
<h3>3. 使用自动注册</h3>
<p>注入自己的依赖到NancyModule中</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">Home</span> <span class="o">:</span> <span class="n">NancyModule</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="n">Home</span><span class="p">(</span><span class="n">IMessageService</span> <span class="n">service</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//If there is only one implementation of IMessageService in the application,</span>
        <span class="c1">// TinyIoC will resolve the dependency on its own and inject it in the module.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h2>十一、视图引擎</h2>
<p>视图引擎就是输入“模板”和“模型”，输出HTML（大部分情况下）到浏览器。</p>
<p>Nancy默认使用<a href="https://github.com/grumpydev/SuperSimpleViewEngine"><code>SuperSimpleViewEngine</code></a>。它支持一些必要的功能：layout布局、partials部分、models模型、conditions条件和iterations循环。你可以使用这个而不无需其他依赖。它支持<code>.html</code>和<code>.sshtml</code>文件。</p>
<div class="highlight"><pre>@Master[&#39;MasterPage&#39;]

@Section[&#39;Content&#39;]
    <span class="nt">&lt;p&gt;</span>This content from the index page<span class="nt">&lt;p&gt;</span>
    <span class="nt">&lt;h3&gt;</span>Partials<span class="nt">&lt;/h3&gt;</span>
    <span class="nt">&lt;p&gt;</span>Login box below rendered via a partial view with no model.<span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;login&quot;</span><span class="nt">&gt;</span>
        @Partial[&#39;login&#39;];
    <span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;p&gt;</span>Box below is rendered via a partial with a sub-model passed in.<span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;p&gt;</span>The submodel is a list which the partial iterates over with Each<span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;users&quot;</span><span class="nt">&gt;</span>
        @Partial[&#39;user&#39;, Model.Users];
    <span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;h3&gt;</span>Encoding<span class="nt">&lt;/h3&gt;</span>
    <span class="nt">&lt;p&gt;</span>Model output can also be encoded:<span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;p&gt;</span>@!Model.NaughtyStuff<span class="nt">&lt;/p&gt;</span>
@EndSection
</pre></div>


<p>除此之外，Nancy还支持Razor, Spark, NDjango和dotLiquid引擎。通过添加引用，Nancy会自动的根据文件后缀名调用对应的引擎。</p>
<h3>1. 在路由中渲染视图</h3>
<div class="highlight"><pre><span class="n">Get</span><span class="p">[</span><span class="s">&quot;/products&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">View</span><span class="p">[</span><span class="s">&quot;products.html&quot;</span><span class="p">,</span> <span class="n">someModel</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


<p>模板说明：
1. 视图文件名: "products.html"
2. 如果没有后缀，而且有多个同名模板，则会收到<code>AmbigiousViewsException</code>错误。
3. 一个相对于跟的路径(比如：<code>products/products.html</code>)</p>
<p>更多参见<a href="https://github.com/NancyFx/Nancy/wiki/View-location-conventions">视图位置约定</a></p>
<h3>2.从模型中解析视图的名称</h3>
<p>如果值传递给View一个模型，Nancy会用模型名（去掉"Model"后缀）作为视图名。</p>
<div class="highlight"><pre><span class="n">Get</span><span class="p">[</span><span class="s">&quot;/products&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">View</span><span class="p">[</span><span class="n">new</span> <span class="n">ProductsModel</span><span class="p">()];</span>
<span class="p">};</span>
</pre></div>


<p>如果找不到，就会报406 Not Acceptable.</p>
<h2>十二、超简单视图引擎</h2>
<p>SSVE基于正则，支持<code>sshtml</code>, <code>html</code>, <code>html</code>文件后缀。</p>
<p>模型可以是标准类型，或者<code>ExpandoObjects</code>（或者实现了<code>IDynamicMetaObjectProvider</code> 实现了<code>IDictionary&lt;string, object&gt;</code>的对象）。</p>
<p>所有的命令都可以有分号，但不是必须的。<code>[.Parameters]</code>这样的参数可以使任意层级的，比如<code>This.Property.That.Property</code>。</p>
<p>注意：所有引号都是_单引号_.</p>
<h3>1. 标准变量替换</h3>
<p>如果变量不能替换，则使用<code>[Err!]</code>替换。</p>
<p>语法：</p>
<div class="highlight"><pre><span class="err">@</span><span class="n">Model</span><span class="p">[.</span><span class="n">Parameters</span><span class="p">]</span>
</pre></div>


<p>例子：</p>
<div class="highlight"><pre><span class="n">Hello</span> <span class="err">@</span><span class="n">Model</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">your</span> <span class="n">age</span> <span class="n">is</span> <span class="err">@</span><span class="n">Model</span><span class="p">.</span><span class="n">User</span><span class="p">.</span><span class="n">Age</span>
</pre></div>


<h3>2. 循环</h3>
<p>循环不能嵌套</p>
<p>语法：</p>
<div class="highlight"><pre><span class="err">@</span><span class="n">Each</span><span class="p">[.</span><span class="n">Parameters</span><span class="p">]</span>
   <span class="p">[</span><span class="err">@</span><span class="n">Current</span><span class="p">[.</span><span class="n">Parameters</span><span class="p">]]</span>
<span class="err">@</span><span class="n">EndEach</span>
</pre></div>


<p><code>@Each</code>表示循环；<code>@Current</code>表示当前变量，使用方法同<code>@Model</code>。</p>
<p>例子：</p>
<div class="highlight"><pre><span class="err">@</span><span class="n">Each</span><span class="p">.</span><span class="n">Users</span>
   <span class="n">Hello</span> <span class="err">@</span><span class="n">Current</span><span class="p">.</span><span class="n">Name</span><span class="o">!</span>
<span class="err">@</span><span class="n">EndEach</span>
</pre></div>


<h3>3. 条件</h3>
<p>参数必须是bool，或能隐式转化。嵌套的@If @IfNot不支持。</p>
<p>语法：</p>
<div class="highlight"><pre><span class="err">@</span><span class="n">If</span><span class="p">[</span><span class="n">Not</span><span class="p">].</span><span class="n">Parameters</span>
   <span class="p">[</span><span class="n">contents</span><span class="p">]</span>
<span class="err">@</span><span class="n">EndIf</span>
</pre></div>


<p>例子：</p>
<div class="highlight"><pre><span class="err">@</span><span class="n">IfNot</span><span class="p">.</span><span class="n">HasUsers</span>
   <span class="n">No</span> <span class="n">users</span> <span class="n">found</span><span class="o">!</span>
<span class="err">@</span><span class="n">EndIf</span>
</pre></div>


<h3>4. 隐式条件</h3>
<p>如果module实现了<code>ICollection</code>，那你就能使用隐式转换。使用<code>Has</code>前缀。</p>
<p>语法：</p>
<div class="highlight"><pre><span class="n">Has</span><span class="p">[</span><span class="n">CollectionPropertyName</span><span class="p">]</span>
</pre></div>


<p>例子：</p>
<div class="highlight"><pre><span class="err">@</span><span class="n">If</span><span class="p">.</span><span class="n">HasUsers</span>
   <span class="n">Users</span> <span class="n">found</span><span class="o">!</span>
<span class="err">@</span><span class="n">EndIf</span>
</pre></div>


<h3>5. HTML编码</h3>
<p><code>@Model</code>和<code>@Current</code>都可以有一个<code>!</code>，用来编码HTML：</p>
<p>语法：</p>
<div class="highlight"><pre><span class="err">@</span><span class="o">!</span><span class="n">Model</span><span class="p">[.</span><span class="n">Parameter</span><span class="p">]</span>
<span class="err">@</span><span class="o">!</span><span class="n">Current</span><span class="p">[.</span><span class="n">Parameter</span><span class="p">]</span>
</pre></div>


<p>例子：</p>
<div class="highlight"><pre><span class="err">@</span><span class="o">!</span><span class="n">Model</span><span class="p">.</span><span class="n">Test</span>

<span class="err">@</span><span class="n">Each</span>
   <span class="err">@</span><span class="o">!</span><span class="n">Current</span><span class="p">.</span><span class="n">Test</span>
<span class="err">@</span><span class="n">EndEach</span>
</pre></div>


<h3>6. 部分Patials</h3>
<p>语法：</p>
<div class="highlight"><pre><span class="err">@</span><span class="n">Partial</span><span class="p">[</span><span class="err">&#39;</span><span class="o">&lt;</span><span class="n">view</span> <span class="n">name</span><span class="o">&gt;</span><span class="err">&#39;</span><span class="p">[,</span> <span class="n">Model</span><span class="p">.</span><span class="n">Property</span><span class="p">]]</span>
</pre></div>


<p>例子：</p>
<div class="highlight"><pre><span class="c1">// Renders the partial view with the same model as the parent</span>
<span class="p">@</span><span class="n">Partial</span><span class="p">[&#39;</span><span class="n">subview</span><span class="p">.</span><span class="n">sshtml</span><span class="p">&#39;];</span>

<span class="c1">// Renders the partial view using the User as the model</span>
<span class="p">@</span><span class="n">Partial</span><span class="p">[&#39;</span><span class="n">subview</span><span class="p">.</span><span class="n">sshtml</span><span class="p">&#39;,</span> <span class="n">Model</span><span class="p">.</span><span class="n">User</span><span class="p">];</span>
</pre></div>


<h3>7. Master页和section</h3>
<p>可以声明master页和节。不必为每个节提供内容。Master能用<code>@Module</code>，并且扩展名可以省略。</p>
<p>可以多次使用<code>@Section</code></p>
<p>语法</p>
<div class="highlight"><pre><span class="p">@</span><span class="nx">Master</span><span class="err">[</span><span class="s1">&#39;&lt;name&gt;&#39;</span><span class="cp">]</span>

@Section<span class="cp">[</span><span class="s1">&#39;&lt;name&gt;&#39;</span><span class="cp">]</span>
@EndSection
</pre></div>


<p>例子：</p>
<div class="highlight"><pre><span class="c1">// master.sshtml</span>
<span class="o">&lt;</span><span class="nx">html</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nb">body</span><span class="o">&gt;</span>
<span class="p">@</span><span class="nx">Section</span><span class="err">[</span><span class="s1">&#39;Content&#39;</span><span class="cp">]</span>;
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>

// index.sshtml
@Master<span class="cp">[</span><span class="s1">&#39;master.sshtml&#39;</span><span class="cp">]</span>

@Section<span class="cp">[</span><span class="s1">&#39;Content&#39;</span><span class="cp">]</span>
   This is content on the index page
@EndSection
</pre></div>


<h3>8. 防止伪造token</h3>
<p>防止CSRF</p>
<p>语法：</p>
<div class="highlight"><pre><span class="err">@</span><span class="n">AntiForgeryToken</span>
</pre></div>


<p>例子：</p>
<div class="highlight"><pre><span class="err">@</span><span class="n">AntiForgeryToken</span>
</pre></div>


<h3>9. 路径扩展</h3>
<p>扩展相对路径为整体路径。</p>
<p>语法：</p>
<div class="highlight"><pre><span class="err">@</span><span class="n">Path</span><span class="p">[</span><span class="err">&#39;</span><span class="o">&lt;</span><span class="n">relative</span><span class="o">-</span><span class="n">path</span><span class="o">&gt;</span><span class="err">&#39;</span><span class="p">]</span>
</pre></div>


<p>例子：</p>
<div class="highlight"><pre><span class="err">@</span><span class="n">Path</span><span class="p">[</span><span class="err">&#39;</span><span class="o">~/</span><span class="n">relative</span><span class="o">/</span><span class="n">url</span><span class="o">/</span><span class="n">image</span><span class="p">.</span><span class="n">png</span><span class="err">&#39;</span><span class="p">]</span>
</pre></div>


<h3>10. 扩展SSVE</h3>
<h2>十二、Razor引擎</h2>
<p>这个Razor引擎跟ASP.NET MVC的有点不一样。</p>
<p>注意，Nancy仍然绑定模型到<code>@Model</code>，而不是ASP.NET中的<code>@model</code></p>
<h3>1. 安装Razor</h3>
<p>只需要添加<code>Nancy.ViewEngines.Razor.dll</code>（使用nuget安装<code>Nancy.ViewEngines.Razor</code>）。然后试图模板以<code>cshtml</code>或<code>vbhtml</code>结尾即可。</p>
<h3>2. 配置Razor</h3>
<h2>十三、实现自己的视图引擎需要注意的地方</h2>
<h2>十四、视图位置约定</h2>
<h3>1. 查看默认约定</h3>
<p>视图位置的约定通过<code>Func&lt;string, dynamic, ViewLocationContext, string&gt;</code>方法以及下面的一些默认约定来定义。</p>
<h4>1.1 根约定</h4>
<div class="highlight"><pre><span class="p">(</span><span class="n">viewName</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">viewLocationContext</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">viewName</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这个约定会在根目录里寻找视图。但是如果视图包含一个相对路径，视图名称执行对应于根路径的路径。比如，视图<code>admin/index</code>会在<code>admin/index</code>目下寻找视图。</p>
<h4>1.2 视图文件夹约定</h4>
<div class="highlight"><pre><span class="p">(</span><span class="n">viewName</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">viewLocationContext</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">string</span><span class="p">.</span><span class="n">Concat</span><span class="p">(</span><span class="s">&quot;views/&quot;</span><span class="p">,</span> <span class="n">viewName</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>很简单，视图<code>admin/index</code>会在<code>views/admin/index</code>下查找对应的视图。</p>
<h4>1.3 视图和模块路径约定</h4>
<div class="highlight"><pre><span class="p">(</span><span class="n">viewName</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">viewLocationContext</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">string</span><span class="p">.</span><span class="n">Concat</span><span class="p">(</span><span class="s">&quot;views/&quot;</span><span class="p">,</span> <span class="n">viewLocationContext</span><span class="p">.</span><span class="n">ModulePath</span><span class="p">,</span> <span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="n">viewName</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>对于模块products的视图<code>admin/index</code>，会在<code>views/products/admin/index</code>中查找视图。</p>
<h4>1.4 模块路径约定</h4>
<div class="highlight"><pre><span class="p">(</span><span class="n">viewName</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">viewLocationContext</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">string</span><span class="p">.</span><span class="n">Concat</span><span class="p">(</span><span class="n">viewLocationContext</span><span class="p">.</span><span class="n">ModulePath</span><span class="p">,</span> <span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="n">viewName</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>这个约定会在与模块名相同的文件夹中查找视图。</p>
<h4>1.5 模块名称约定</h4>
<div class="highlight"><pre><span class="p">(</span><span class="n">viewName</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">viewLocationContext</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">string</span><span class="p">.</span><span class="n">Concat</span><span class="p">(</span><span class="n">viewLocationContext</span><span class="p">.</span><span class="n">ModuleName</span><span class="p">,</span> <span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="n">viewName</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>查找以模块名为前缀的对应视图。</p>
<h4>1.6 视图模块名称约定</h4>
<div class="highlight"><pre><span class="p">(</span><span class="n">viewName</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">viewLocationContext</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">string</span><span class="p">.</span><span class="n">Concat</span><span class="p">(</span><span class="s">&quot;views/&quot;</span><span class="p">,</span> <span class="n">viewLocationContext</span><span class="p">.</span><span class="n">ModuleName</span><span class="p">,</span> <span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="n">viewName</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>查找views文件夹下以模块名为前缀的对应视图。</p>
<h3>2. 从模型类型推断是退名</h3>
<p>如果没有提供视图名而只提供了视图，那么：</p>
<ul>
<li><code>Customer</code>类型的模型-&gt;<code>Customer</code>视图名</li>
<li><code>CustomerModel</code>类型的模型-&gt; <code>Customer</code>视图名</li>
</ul>
<h3>3. 自定义约定</h3>
<p>自定义一个bootstrapper，然后添加约定到<code>Conventions.ViewLocationConventions</code>集合。</p>
<p>比如：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">CustomConventionsBootstrapper</span> <span class="o">:</span> <span class="n">DefaultNancyBootstrapper</span>
<span class="p">{</span>
    <span class="n">protected</span> <span class="n">override</span> <span class="kt">void</span> <span class="n">ApplicationStartup</span><span class="p">(</span><span class="n">TinyIoCContainer</span> <span class="n">container</span><span class="p">,</span> <span class="n">Nancy</span><span class="p">.</span><span class="n">Bootstrapper</span><span class="p">.</span><span class="n">IPipelines</span> <span class="n">pipelines</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">this</span><span class="p">.</span><span class="n">Conventions</span><span class="p">.</span><span class="n">ViewLocationConventions</span><span class="p">.</span><span class="n">Add</span><span class="p">((</span><span class="n">viewName</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">string</span><span class="p">.</span><span class="n">Concat</span><span class="p">(</span><span class="s">&quot;custom/&quot;</span><span class="p">,</span> <span class="n">viewName</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>比如这个会查找custom文件夹下的视图名称。</p>
<p><code>ViewLocationConventions</code>是一个标准的列表，可以进行修改。</p>
<h3>3. 使用IConventions定义自己的约定</h3>
<p>你也可以实现<code>IConvention</code>接口，并在<code>Initialise</code>方法中添加约定到<code>ViewLocationConventions</code>属性中。</p>
<p>Nancy会定位所有接口的实现，并且执行约定，这些发生在他们被传递给bootstrapper的<code>ConfigureConventions</code>方法之前。</p>
<h2>十五、本地化</h2>
<p>Nancy内建了本地化。有一系列的<a href="https://github.com/NancyFx/Nancy/blob/master/src/Nancy/Conventions/DefaultCultureConventions.cs">约定</a>描述了如何决定当前文化，还有一些根据文化选择视图的<a href="https://github.com/NancyFx/Nancy/blob/master/src/Nancy/Conventions/DefaultViewLocationConventions.cs">约定</a>。</p>
<p>所以，对于<code>de-DE</code>的文化他会寻找<code>Home-de-DE</code>的视图。</p>
<p>不仅如此，还会有rese文件，比如<code>Text.resx</code>， <code>Text.de-DE.resx</code>（可以被<a href="https://github.com/NancyFx/Nancy/blob/master/src/Nancy/Localization/ResourceBasedTextResource.cs">重写</a>).</p>
<p>Razor本地化的<a href="https://github.com/NancyFx/Nancy/tree/master/src/Nancy.Demo.Razor.Localization">例子</a></p>
<h2>十六、测试应用</h2>
<p>使用<a href="http://nuget.org/">NuGet</a>来安装<code>Nancy.Testing</code>。</p>
<p>测试应当与主应用分开。</p>
<p>为了测试路由，使用helper类<code>Browser</code>。使用bootstrap实例化Browser。</p>
<div class="highlight"><pre><span class="k">[Fact]</span>
<span class="err">public</span> <span class="err">void</span> <span class="err">Should_return_status_ok_when_route_exists()</span>
<span class="err">{</span>
    <span class="err">//</span> <span class="err">Given</span>
    <span class="na">var bootstrapper</span> <span class="o">=</span> <span class="s">new DefaultNancyBootstrapper();</span>
<span class="s">    var browser = new Browser(bootstrapper);</span>

    <span class="err">//</span> <span class="err">When</span>
    <span class="na">var result</span> <span class="o">=</span> <span class="s">browser.Get(&quot;/&quot;, with =&gt; {</span>
<span class="s">        with.HttpRequest();</span>
<span class="s">    });</span>

    <span class="err">//</span> <span class="err">Then</span>
    <span class="err">Assert.Equal(HttpStatusCode.OK,</span> <span class="err">result.StatusCode)</span><span class="c1">;</span>
<span class="err">}</span>
</pre></div>


<h2>十七、根路径</h2>
<p>Nancy通过<code>IRootPathProvider</code>接口的唯一方法<code>GetRootPath</code>来确定根路径。</p>
<h3>1. 改变跟路径</h3>
<p>改变根路径需要做两件事：</p>
<p>首先，自定义一个类实现<code>IRootPathProvider</code>：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">CustomRootPathProvider</span> <span class="o">:</span> <span class="n">IRootPathProvider</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="n">string</span> <span class="n">GetRootPath</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;What ever path you want to use as your application root&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>注意，根路径是绝对路径。</p>
<p>其次，在自定义的Bootstrapper中重写<code>RootPathProvider</code>属性。</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">CustomBootstrapper</span> <span class="o">:</span> <span class="n">DefaultNancyBootstrapper</span>
<span class="p">{</span>
    <span class="n">protected</span> <span class="n">override</span> <span class="n">IRootPathProvider</span> <span class="n">RootPathProvider</span>
    <span class="p">{</span>
        <span class="n">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">new</span> <span class="n">CustomRootPathProvider</span><span class="p">();</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3>2. 上传文件</h3>
<p>在Nancy中要上传文件，你需要接受上传文件的content stream, 在磁盘上创建文件，并将stream写入到磁盘。</p>
<div class="highlight"><pre><span class="n">var</span> <span class="n">uploadDirectory</span> <span class="o">=</span>  <span class="n">Path</span><span class="p">.</span><span class="n">Combine</span><span class="p">(</span><span class="n">pathProvider</span><span class="p">.</span><span class="n">GetRootPath</span><span class="p">(),</span> <span class="s">&quot;Content&quot;</span><span class="p">,</span> <span class="s">&quot;uploads&quot;</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Directory</span><span class="p">.</span><span class="n">Exists</span><span class="p">(</span><span class="n">uploadDirectory</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">Directory</span><span class="p">.</span><span class="n">CreateDirectory</span><span class="p">(</span><span class="n">uploadDirectory</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">foreach</span> <span class="p">(</span><span class="n">var</span> <span class="n">file</span> <span class="n">in</span> <span class="n">Request</span><span class="p">.</span><span class="n">Files</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">var</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">Path</span><span class="p">.</span><span class="n">Combine</span><span class="p">(</span><span class="n">uploadDirectory</span><span class="p">,</span> <span class="n">file</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
    <span class="n">using</span> <span class="p">(</span><span class="n">FileStream</span> <span class="n">fileStream</span> <span class="o">=</span> <span class="n">new</span> <span class="n">FileStream</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">FileMode</span><span class="p">.</span><span class="n">Create</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">file</span><span class="p">.</span><span class="n">Value</span><span class="p">.</span><span class="n">CopyTo</span><span class="p">(</span><span class="n">fileStream</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>上例中的<code>pathProvider</code>是在模块的构造函数中传递进来的，通过它的<code>GetRootPath()</code>来获取跟路径。</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">HomeModule</span><span class="p">(</span><span class="n">IRootPathProvider</span> <span class="n">pathProvider</span><span class="p">)</span>
</pre></div>


<h2>十八、管理静态内容</h2>
<p><strong>简而言之：把东西都放到<code>/Content</code>文件夹内，仅此而已</strong></p>
<h2>十九、诊断</h2>
<p>Nancy自带诊断功能：<code>http://&lt;address-of-your-application&gt;/_Nancy/</code></p>
<h3>1. 配置到dashboard的访问</h3>
<p>添加密码：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">CustomBootstrapper</span> <span class="o">:</span> <span class="n">DefaultNancyBootstrapper</span>
<span class="p">{</span>
    <span class="n">protected</span> <span class="n">override</span> <span class="n">DiagnosticsConfiguration</span> <span class="n">DiagnosticsConfiguration</span>
    <span class="p">{</span>
        <span class="n">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">new</span> <span class="n">DiagnosticsConfiguration</span> <span class="p">{</span> <span class="n">Password</span> <span class="o">=</span> <span class="s">@&quot;A2</span><span class="se">\6</span><span class="s">mVtH/XRT\p,B&quot;</span><span class="p">};</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3>2. 去除诊断</h3>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">CustomBootstrapper</span> <span class="o">:</span> <span class="n">DefaultNancyBootstrapper</span>
<span class="p">{</span>
    <span class="n">protected</span> <span class="n">override</span> <span class="kt">void</span> <span class="n">ApplicationStartup</span><span class="p">(</span><span class="n">TinyIoc</span><span class="p">.</span><span class="n">TinyIoCContainer</span> <span class="n">container</span><span class="p">,</span> <span class="n">IPipelines</span> <span class="n">pipelines</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DiagnosticsHook</span><span class="p">.</span><span class="n">Disable</span><span class="p">(</span><span class="n">pipelines</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3>3. 有哪些工具呢？</h3>
<p><code>Information</code>, <code>Interactive Diagnostics</code>, <code>Request Tracing</code>, <code>Configuration</code></p>
<h4>3.1 信息</h4>
<h4>3.2 配置</h4>
<p>Nancy中<code>StaticConfiguration</code>可以用来配置程序的行为，配置页面提供了配置方法。</p>
<p>注意，系统重启后配置页面的内容失效。</p>
<p>要想永久保存配置，请在bootstrapper的<code>ApplicationStartup</code>中设置。</p>
<h4>3.3 请求跟踪</h4>
<p>请求跟踪因为性能原因默认关闭，可以再<code>Configuration</code>页开启，也可以这样：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">CustomBootstrapper</span> <span class="o">:</span> <span class="n">DefaultNancyBootstrapper</span>
<span class="p">{</span>
    <span class="n">protected</span> <span class="n">override</span> <span class="kt">void</span> <span class="n">ApplicationStartup</span><span class="p">(</span><span class="n">TinyIoC</span><span class="p">.</span><span class="n">TinyIoCContainer</span> <span class="n">container</span><span class="p">,</span> <span class="n">IPipelines</span> <span class="n">pipelines</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">StaticConfiguration</span><span class="p">.</span><span class="n">EnableRequestTracing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>跟踪日志可以通过<code>NancyContext</code>中得到。和容易添加自己的内容：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">HomeModule</span> <span class="o">:</span> <span class="n">NancyModule</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="n">HomeModule</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Get</span><span class="p">[</span><span class="s">&quot;/&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">this</span><span class="p">.</span><span class="n">Context</span><span class="p">.</span><span class="n">Trace</span><span class="p">.</span><span class="n">TraceLog</span><span class="p">.</span><span class="n">WriteLog</span><span class="p">(</span><span class="n">s</span> <span class="o">=&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">AppendLine</span><span class="p">(</span><span class="s">&quot;Root path was called&quot;</span><span class="p">));</span>
            <span class="k">return</span> <span class="n">HttpStatusCode</span><span class="p">.</span><span class="n">Ok</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p><code>WriteLog</code>方法是用一个接受<code>StringBuilder</code>的函数是为了调试关闭时直接不调用函数，从而避免性能损耗。</p>
<h4>3.4 交互式的诊断</h4>
<p>只要实现了<code>IDiagnosticsProvider</code>接口，Nancy诊断会自动发现它，并且把它暴露给交互工具。</p>
<h5>（1）IDiagnosticsProvider接口</h5>
<div class="highlight"><pre><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// Defines the functionality a diagnostics provider.</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="k">public</span> <span class="nf">interface</span> <span class="nx">IDiagnosticsProvider</span>
<span class="p">{</span>
    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Gets the name of the provider.</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="c1">/// &lt;value&gt;A &lt;see cref=&quot;string&quot;/&gt; containing the name of the provider.&lt;/value&gt;</span>
   <span class="kt">string</span> <span class="nb">Name</span> <span class="p">{</span> <span class="nb">get</span><span class="p">;</span> <span class="p">}</span>

   <span class="c1">/// &lt;summary&gt;</span>
   <span class="c1">/// Gets the description of the provider.</span>
   <span class="c1">/// &lt;/summary&gt;</span>
   <span class="c1">/// &lt;value&gt;A &lt;see cref=&quot;string&quot;/&gt; containing the description of the provider.&lt;/value&gt;</span>
   <span class="kt">string</span> <span class="nb">Description</span> <span class="p">{</span> <span class="nb">get</span><span class="p">;</span> <span class="p">}</span>

   <span class="c1">/// &lt;summary&gt;</span>
   <span class="c1">/// Gets the object that contains the interactive diagnostics methods.</span>
   <span class="c1">/// &lt;/summary&gt;</span>
   <span class="c1">/// &lt;value&gt;An instance of the interactive diagnostics object.&lt;/value&gt;</span>
   <span class="nb">object</span> <span class="nx">DiagnosticObject</span> <span class="p">{</span> <span class="nb">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h5>（2）可诊断的对象</h5>
<p>任何公共方法都会暴露给交互诊断面板。方法可以是能被JSON序列化的任意类型。类型的返回值会被返回成<a href="http://www.servicestack.net/docs/framework/json-report-format">JSON Report Format</a></p>
<h5>（3）提供描述给方法</h5>
<p>两种方法：
1、使用attribute: <code>Nancy.Diagnostics.DescriptionAttribute</code></p>
<p>2、使用property：使用与方法同名但添加了<code>Description</code>后缀的属性，比如<code>NameOfYourMethodDescription</code>描述了<code>NameOfYourMethod</code>方法。</p>
<h5>（4）自定义模板输出</h5>
<h5>（5）创建诊断提供者</h5>
<h2>二十、添加自己的favicon</h2>
<h3>1. 替换默认的FavIcon</h3>
<p>在应用中防止一个_favicon_的文件，名称以<code>.icon</code>或<code>.png</code>结尾即可。</p>
<h3>2. 使用内嵌icon</h3>
<p>在Bootstrapper中重写<code>FavIcon</code>属性：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">Bootstrapper</span> <span class="o">:</span> <span class="n">DefaultNancyBootstrapper</span>
<span class="p">{</span>
    <span class="n">private</span> <span class="n">byte</span><span class="p">[]</span> <span class="n">favicon</span><span class="p">;</span>

    <span class="n">protected</span> <span class="n">override</span> <span class="n">byte</span><span class="p">[]</span> <span class="n">FavIcon</span>
    <span class="p">{</span>
        <span class="n">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">this</span><span class="p">.</span><span class="n">favicon</span><span class="o">??</span> <span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">favicon</span><span class="o">=</span> <span class="n">LoadFavIcon</span><span class="p">());</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">private</span> <span class="n">byte</span><span class="p">[]</span> <span class="n">LoadFavIcon</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">//TODO: remember to replace &#39;AssemblyName&#39; with the prefix of the resource</span>
        <span class="n">using</span> <span class="p">(</span><span class="n">var</span> <span class="n">resourceStream</span> <span class="o">=</span> <span class="n">GetType</span><span class="p">().</span><span class="n">Assembly</span><span class="p">.</span><span class="n">GetManifestResourceStream</span><span class="p">(</span><span class="s">&quot;AssemblyName.favicon.ico&quot;</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">var</span> <span class="n">tempFavicon</span> <span class="o">=</span> <span class="n">new</span> <span class="n">byte</span><span class="p">[</span><span class="n">resourceStream</span><span class="p">.</span><span class="n">Length</span><span class="p">];</span>
            <span class="n">resourceStream</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="n">tempFavicon</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">resourceStream</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">tempFavicon</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3>3. 移除ICON</h3>
<p>设置Bootstrapper的<code>FavIcon</code>属性为<code>null</code>。</p>
<h2>二十一、添加自定义的错误页面</h2>
<p>第一篇:http://mike-ward.net/blog/post/00824/custom-error-pages-in-nancyfx</p>
<p>第二篇：https://blog.tommyparnell.com/custom-error-pages-in-nancy/</p>
<h2>二十二、加密帮助方法</h2>
<p>命名空间:<code>Nancy.Cryptography</code></p>
<h3>1. IEncryptionProvider 接口</h3>
<div class="highlight"><pre><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// Provides symmetrical encryption support</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="k">public</span> <span class="nf">interface</span> <span class="nx">IEncryptionProvider</span>
<span class="p">{</span>
    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Encrypt and base64 encode the string</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="c1">/// &lt;param name=&quot;data&quot;&gt;Data to encrypt&lt;/param&gt;</span>
    <span class="c1">/// &lt;returns&gt;Encrypted string&lt;/returns&gt;</span>
    <span class="kt">string</span> <span class="nx">Encrypt</span><span class="p">(</span><span class="kt">string</span> <span class="kd">data</span><span class="p">);</span>

    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Decrypt string</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="c1">/// &lt;param name=&quot;data&quot;&gt;Data to decrypt&lt;/param&gt;</span>
    <span class="c1">/// &lt;returns&gt;Decrypted string&lt;/returns&gt;</span>
    <span class="kt">string</span> <span class="nx">Decrypt</span><span class="p">(</span><span class="kt">string</span> <span class="kd">data</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Nancy提供了两个默认实现</p>
<ul>
<li><code>NoEncryptionProvider</code>:没有加密，仅仅是base64</li>
<li><code>RijndaelEncryptionProvider</code>: 使用Rijndael算法，使用256位的key和128为的初始向量，加密base64字符串。</li>
</ul>
<h3>2. IHmacProvider 接口</h3>
<p>用来签名，防止篡改。</p>
<div class="highlight"><pre><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// Creates Hash-based Message Authentication Codes (HMACs)</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="k">public</span> <span class="nf">interface</span> <span class="nx">IHmacProvider</span>
<span class="p">{</span>
    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Gets the length of the HMAC signature in bytes</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="nx">int</span> <span class="nx">HmacLength</span> <span class="p">{</span> <span class="nb">get</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Create a hmac from the given data</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="c1">/// &lt;param name=&quot;data&quot;&gt;Data to create hmac from&lt;/param&gt;</span>
    <span class="c1">/// &lt;returns&gt;Hmac bytes&lt;/returns&gt;</span>
    <span class="nx">byte</span><span class="err">[</span><span class="cp">]</span> GenerateHmac(string data);

    /// <span class="nt">&lt;summary&gt;</span>
    /// Create a hmac from the given data
    /// <span class="nt">&lt;/summary&gt;</span>
    /// <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">&quot;data&quot;</span><span class="nt">&gt;</span>Data to create hmac from<span class="nt">&lt;/param&gt;</span>
    /// <span class="nt">&lt;returns&gt;</span>Hmac bytes<span class="nt">&lt;/returns&gt;</span>
    byte<span class="cp">[]</span> GenerateHmac(byte<span class="cp">[]</span> data);
}
</pre></div>


<p>Nancy也提供了一个默认实现：<code>DefaultHmacProvider</code>，使用<code>IKeyGenerator</code>来产生一个key来用SHA-256来进行hash。</p>
<h3>3. IKeyGenerator 接口</h3>
<p>用来产生key来加密和数字签名。</p>
<div class="highlight"><pre><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// Provides key byte generation</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="k">public</span> <span class="nf">interface</span> <span class="nx">IKeyGenerator</span>
<span class="p">{</span>
    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Generate a sequence of bytes</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="c1">/// &lt;param name=&quot;count&quot;&gt;Number of bytes to return&lt;/param&gt;</span>
    <span class="c1">/// &lt;returns&gt;Array &lt;see cref=&quot;count&quot;/&gt; bytes&lt;/returns&gt;</span>
    <span class="nx">byte</span><span class="err">[</span><span class="cp">]</span> GetBytes(int count);
}
</pre></div>


<p>Nancy提供了两个默认实现。</p>
<ul>
<li>
<p><code>RandomKeyGenerator</code>使用<code>RNGCryptoServiceProvider</code>产生了一个随机定长的key</p>
</li>
<li>
<p><code>PassphraseKeyGenerator</code>使用密码、静态盐以及可选循环数字，以及<code>Rfc2898DeriveBytes</code>来产生一个key</p>
</li>
</ul>
<p><strong>注意</strong>，如果使用<code>PassphraseKeyGenerator</code>，它的初始化应当在应用启动时使用，因为它太慢了。这意味着盐是静态的，因此密码一定要足够长和复杂。</p>
<h3>4. 加密配置类型CryptographyConfiguration</h3>
<p>这是一个存储<code>IEncryptionProvider</code>和<code>IHmacProvider</code>的简便方法。它有两个静态属性：</p>
<ul>
<li><code>Default</code>使用<code>RijndaelEncryptionProvider</code>和<code>DefaultHmacProvider</code>，两个都使用<code>RandomKeyGenerator</code>。</li>
<li><code>NoEncryption</code>使用<code>NoEncryption</code>和<code>DefaultHmacProvider</code>，两个也都使用<code>RandomKeyGenerator</code>.</li>
</ul>
<p>可以单独使用<code>CryptographyConfiguration</code>，也可以在bootstrapper中配置一个：</p>
<div class="highlight"><pre><span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// Gets the cryptography configuration</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="k">protected</span> <span class="nf">virtual</span> <span class="nx">CryptographyConfiguration</span> <span class="nx">CryptographyConfiguration</span>
<span class="p">{</span>
    <span class="nb">get</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">CryptographyConfiguration.Default</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h2>二十三、Content negotiation(内容协商)</h2>
<p>当返回不是<code>Response</code>类型时，使用response processor来根据请求的<code>Accept</code>来处理。</p>
<h3>1. Response Processor</h3>
<div class="highlight"><pre><span class="k">public</span> <span class="nf">interface</span> <span class="nx">IResponseProcessor</span>
<span class="p">{</span>
    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Gets a set of mappings that map a given extension (such as .json)</span>
    <span class="c1">/// to a media range that can be sent to the client in a vary header.</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="nx">IEnumerable</span><span class="o">&lt;</span><span class="nx">Tuple</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="nx">MediaRange</span><span class="o">&gt;&gt;</span> <span class="nx">ExtensionMappings</span> <span class="p">{</span> <span class="nb">get</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Determines whether the the processor can handle a given content type and model.</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="nx">ProcessorMatch</span> <span class="nx">CanProcess</span><span class="p">(</span><span class="nx">MediaRange</span> <span class="nx">requestedMediaRange</span><span class="p">,</span> <span class="nx">dynamic</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">NancyContext</span> <span class="nx">context</span><span class="p">);</span>

    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Process the response.</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="nb">Response</span> <span class="nb">Process</span><span class="p">(</span><span class="nx">MediaRange</span> <span class="nx">requestedMediaRange</span><span class="p">,</span> <span class="nx">dynamic</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">NancyContext</span> <span class="nx">context</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Response Processor是自发现的，也可以在Bootstrap中配置。</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">Bootstrapper</span> <span class="o">:</span> <span class="n">DefaultNancyBootstrapper</span>
<span class="p">{</span>
    <span class="n">protected</span> <span class="n">override</span> <span class="n">NancyInternalConfiguration</span> <span class="n">InternalConfiguration</span>
    <span class="p">{</span>
        <span class="n">get</span>
        <span class="p">{</span>
            <span class="n">var</span> <span class="n">processors</span> <span class="o">=</span> <span class="n">new</span><span class="p">[]</span>
            <span class="p">{</span>
                <span class="n">typeof</span><span class="p">(</span><span class="n">SomeProcessor</span><span class="p">),</span>
                <span class="n">typeof</span><span class="p">(</span><span class="n">AnotherProcessor</span><span class="p">)</span>
            <span class="p">};</span>

            <span class="k">return</span> <span class="n">NancyInternalConfiguration</span><span class="p">.</span><span class="n">WithOverrides</span><span class="p">(</span><span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">ResponseProcessors</span> <span class="o">=</span> <span class="n">processors</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4>1.1 匹配优先级</h4>
<p>当相应准备转化请求媒体的格式时，Nancy会查询所有的processor的<code>CanProcess</code>方法，并且会聚合<code>ProcessorMatch</code>的返回值。</p>
<p><code>ProcessorMatch</code>类型确保每个processor让Nancy知道它们对媒体类型的支持程度。</p>
<div class="highlight"><pre><span class="k">public</span> <span class="nf">class</span> <span class="nx">ProcessorMatch</span>
<span class="p">{</span>
    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Gets or sets the match result based on the content type</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="k">public</span> <span class="nf">MatchResult</span> <span class="nx">RequestedContentTypeResult</span> <span class="p">{</span> <span class="nb">get</span><span class="p">;</span> <span class="nb">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Gets or sets the match result based on the model</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="k">public</span> <span class="nf">MatchResult</span> <span class="nx">ModelResult</span> <span class="p">{</span> <span class="nb">get</span><span class="p">;</span> <span class="nb">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p><code>MatchResult</code>枚举了匹配程度：</p>
<div class="highlight"><pre><span class="k">public</span> <span class="nf">enum</span> <span class="nx">MatchResult</span>
<span class="p">{</span>
    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// No match, nothing to see here, move along</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="nx">NoMatch</span><span class="p">,</span>

    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Will accept anything</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="nx">DontCare</span><span class="p">,</span>

    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Matched, but in a non-specific way such as a wildcard match or fallback</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="nx">NonExactMatch</span><span class="p">,</span>

    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Exact specific match</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="nx">ExactMatch</span>
<span class="p">}</span>
</pre></div>


<p>所有的<code>ProcessorMatch</code>会按照Match程度降序排列，最匹配的被执行。如果有两个匹配程度相同，Nancy会选择其中一个。</p>
<h4>1.2 默认响应处理器</h4>
<p>Nancy提供了一些默认响应处理器</p>
<ul>
<li><code>JsonProcessor</code> - 当请求类型为<code>application/json</code>或者<code>application/vnd.foobar+json</code>时，转化返回值为json；</li>
<li><code>ViewProcessor</code> - 当请求类型为<code>text/html</code>时，使用返回值作为model，返回视图。视图使用<a href="https://github.com/NancyFx/Nancy/wiki/View-location-conventions">视图位置约定</a>；</li>
<li><code>XmlProcessor</code> - 当请求为<code>application/xml</code>或者为<code>application/vnd.foobar+xml</code>时，返回xml。</li>
</ul>
<h3>2. 控制协商</h3>
<p><code>Nancy.Responses.Negotiation</code>命名空间中的<code>Negotiator</code>用来控制协商。<code>Negotiator</code>有一个属性：<code>NegotiationContext</code>. <code>NegotiationContext</code>可以用来控制响应的协商。</p>
<p>但是一般不会直接使用<code>Negotiator</code>和<code>NegotiationContext</code>，因为<code>NancyModule</code>包含了一个帮助方法<code>Negotiate</code>，用来更好的创造<code>Negotiator</code>实例。</p>
<p>在路由中使用<code>Negotiator</code>的例子：</p>
<div class="highlight"><pre><span class="n">Get</span><span class="p">[</span><span class="s">&quot;/&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Negotiate</span>
        <span class="p">.</span><span class="n">WithModel</span><span class="p">(</span><span class="n">new</span> <span class="n">RatPack</span> <span class="p">{</span><span class="n">FirstName</span> <span class="o">=</span> <span class="s">&quot;Nancy &quot;</span><span class="p">})</span>
        <span class="p">.</span><span class="n">WithMediaRangeModel</span><span class="p">(</span><span class="s">&quot;text/html&quot;</span><span class="p">,</span> <span class="n">new</span> <span class="n">RatPack</span> <span class="p">{</span><span class="n">FirstName</span> <span class="o">=</span> <span class="s">&quot;Nancy fancy pants&quot;</span><span class="p">})</span>
        <span class="p">.</span><span class="n">WithView</span><span class="p">(</span><span class="s">&quot;negotiatedview&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="n">WithHeader</span><span class="p">(</span><span class="s">&quot;X-Custom&quot;</span><span class="p">,</span> <span class="s">&quot;SomeValue&quot;</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>


<p><code>Negotiator</code>包含了用来配置返回<code>Negotiator</code>实例的一些方法。</p>
<ul>
<li><code>WithHeader</code> - 添加一个Http头；</li>
<li><code>WithHeaders</code> - 添加一个Http的头集合；</li>
<li><code>WithView</code> - 使用视图；</li>
<li><code>WithModel</code> - 使用模型；</li>
<li><code>WithMediaRangeModel</code> - 使用特定的媒体类型和模型，如果失败了，就使用<code>WithModel</code>指定的模型；</li>
<li><code>WithFullNegotiation</code> - 设置允许媒体类型为<code>*/*</code>的帮助方法；</li>
<li><code>WithAllowedMediaRange</code> - 指定允许的媒体范围。默认是"/",但是一旦指定一个特定的内容类型，通配符就会被移走。</li>
<li><code>WithStatusCode</code> - 状态码</li>
</ul>
<h3>3. 支持文件扩展名</h3>
<p>Nancy支持基于扩展名来设置协商的处理，此时传递正常的可接受的头。</p>
<p>例子：</p>
<div class="highlight"><pre><span class="n">Get</span><span class="p">[</span><span class="s">&quot;/ratpack&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">new</span> <span class="n">RatPack</span> <span class="p">{</span><span class="n">FirstName</span> <span class="o">=</span> <span class="s">&quot;Nancy &quot;</span><span class="p">});</span>
<span class="p">};</span>
</pre></div>


<p>它既可以通过<code>/ratpack</code>和设置的<code>application/json</code>头来调用，也可以使用<code>/ratpack.json</code>并且不设置<code>application/json</code>来调用，两个结果一样。</p>
<p>内部Nancy是通过检测扩展名，并查询可用的响应处理器的<code>ExtensionMappings</code>属性来查看是否有支持的扩展。如果有，就调用并且设置对应的头信息，但是如果有更优先的处理器，则用更优先的处理器，除非更优先的处理器失败了，才会使用扩展。</p>
<h3>4. 强制可接受的头(Accept Header)</h3>
<p>约定的格式：</p>
<div class="highlight"><pre><span class="n">Func</span><span class="o">&lt;</span>
   <span class="n">IEnumerable</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">decimal</span><span class="o">&gt;&gt;</span><span class="p">,</span>
   <span class="n">NancyContext</span><span class="p">,</span>
   <span class="n">IEnumerable</span><span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">decimal</span><span class="o">&gt;&gt;&gt;</span>
</pre></div>


<p>这个函数接受<code>NancyContext</code>和当前头，并且期望你返回修改后的可接受头列表。</p>
<p>默认情况下，Nancy在<code>Nancy.Conventions.BuiltInAcceptHeaderCoercions class</code>中提供了如下约定，其中加*的表示是默认默认被转换的：</p>
<ul>
<li><code>BoostHtml</code>(*) - 如果text/html的优先级低于其他内容类型，则提高优先级；</li>
<li><code>CoerceBlankAcceptHeader</code>(*) - 如果没有指定请求头，就分配一个默认的；</li>
<li><code>CoerceStupidBrowsers</code> - 对于老浏览器，替换请求头，即使它们说是请求xml还是返回html。</li>
</ul>
<p>更改哪一个强制起作用时在bootstrapper中的<code>ConfigureConventions</code>来设置的：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">Bootstrapper</span> <span class="o">:</span> <span class="n">DefaultNancyBootstrapper</span>
<span class="p">{</span>
    <span class="n">protected</span> <span class="n">override</span> <span class="kt">void</span> <span class="n">ConfigureConventions</span><span class="p">(</span><span class="n">NancyConventions</span> <span class="n">nancyConventions</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">base</span><span class="p">.</span><span class="n">ConfigureConventions</span><span class="p">(</span><span class="n">nancyConventions</span><span class="p">);</span>

        <span class="n">this</span><span class="p">.</span><span class="n">Conventions</span><span class="p">.</span><span class="n">AcceptHeaderCoercionConventions</span><span class="p">.</span><span class="n">Add</span><span class="p">((</span><span class="n">acceptHeaders</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>

            <span class="c1">// Modify the acceptHeaders by adding, removing or updating the current</span>
            <span class="c1">// values.</span>

            <span class="k">return</span> <span class="n">acceptHeaders</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>当然你也可以继承你自己的bootstrapper。</p>
<h3>5. 使用IConventions来定义自己的约定</h3>
<p>可以通过实现<code>IConventions</code>接口来创造一个类，并在它的<code>Initialise</code>方法中添加自己的约定到传递进来的参数的<code>AcceptHeaderCoercionConventions</code>属性中。</p>
<p>在所有的接口被传递给bootstrapper的<code>ConfigureConventions</code>的方法之前，Nancy会定位所有的接口实现，并且激发这些约定。</p>
<h3>6. 自动协商头</h3>
<p>Nancy会自动添加链接和各种各样的头到协商响应中。链接头链接。连接头会连接到根据文件扩展来的其他代表中。</p>
<h3>7. 更多信息</h3>
<ul>
<li><a href="http://www.philliphaydon.com/2012/11/nancy-and-content-negotiation/">Nancy and Content Negotiation</a></li>
<li><a href="http://www.philliphaydon.com/2013/04/nancyfx-revisiting-content-negotiation-and-apis-part-1/">Revisting Content Negotiation and APIs part 1</a></li>
<li><a href="http://www.philliphaydon.com/2013/05/nancyfx-revisiting-content-negotiation-and-apis-part-2/">Revisting Content Negotiation and APIs part 2</a></li>
<li><a href="http://www.philliphaydon.com/2013/05/nancyfx-revisiting-content-negotiation-and-apis-part-3/">Revisting Content Negotiation and APIs part 3</a></li>
</ul>
<h2>二十四、使用转换器来扩展序列化</h2>
<h2>二十五、授权</h2>
<p>Nancy中的验证使用扩展点：比如应用管道、模块管道、<code>NancyContext</code>和其他的一些扩展方法。所以你可以写自己的验证来替换默认提供的验证。</p>
<p>Nancy提供了以下几种验证，通过Nuget安装：</p>
<ul>
<li>表单(<code>Nancy.Authentication.Forms</code>)</li>
<li>基本(<code>Nancy.Authentication.Basic</code>)</li>
<li>无状态(<code>Nancy.Authentication.Stateless</code>)</li>
</ul>
<h3>1. 了解用户</h3>
<p>Nancy中用户使用<code>IUserIdentity</code>接口代表，它提供了一些用户的基本信息：</p>
<div class="highlight"><pre><span class="k">public</span> <span class="nf">interface</span> <span class="nx">IUserIdentity</span>
<span class="p">{</span>
    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Gets or sets the name of the current user.</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="kt">string</span> <span class="nx">UserName</span> <span class="p">{</span> <span class="nb">get</span><span class="p">;</span> <span class="nb">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Gets or set the claims of the current user.</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="nx">IEnumerable</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span> <span class="nx">Claims</span> <span class="p">{</span> <span class="nb">get</span><span class="p">;</span> <span class="nb">set</span><span class="p">;</span> <span class="p">}</span> 
<span class="p">}</span>
</pre></div>


<p>你应当提供基于自己应用需求的类来实现自己的用户接口。</p>
<p>要获得当前用户，只需要获取<code>NancyContext</code>的<code>CurrentUser</code>属性。返回<code>null</code>值表明当前请求未认证，其他的则表示已认证。</p>
<p>context在Nancy的大部分地方都能获取，所以不必担心能否获取当前请求的用户身份。</p>
<h3>2. 保护你的资源</h3>
<p>可以在模块级和应用级来保护资源，方法是检测<code>NancyContext.CurrentUser</code>属性不为null。</p>
<p>这个任务可以通过在<a href="https://github.com/NancyFx/Nancy/wiki/The%20before%20and%20after%20module%20hooks">模块管道</a>的<code>Before</code>中实现。这个钩子允许我们终结当前请求的执行，返回其它资源，比如当未验证用户视图访问安全资源时：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">SecureModule</span> <span class="o">:</span> <span class="n">NancyModule</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="n">SecureModule</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Before</span> <span class="o">+=</span> <span class="n">ctx</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">Context</span><span class="p">.</span><span class="n">CurrentUser</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span> <span class="o">?</span> <span class="n">new</span> <span class="n">HtmlResponse</span><span class="p">(</span><span class="n">HttpStatusCode</span><span class="p">.</span><span class="n">Unauthorized</span><span class="p">)</span> <span class="o">:</span> <span class="n">null</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="c1">// Your routes here</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>在每个模块上添加安全代码违反了DRY原则，更是一个无聊的任务。使用扩展方法！</p>
<p>Nancy有一些扩展方法包装了这些任务，彻底的减少了要写的代码量。</p>
<p>下面是一些可用的扩展方法：</p>
<ul>
<li><code>RequiresAuthentication</code> - 确保验证用户是可用的，或者返回<code>HttpStatusCode.Unauthorized</code>. 对于认证的用户，<code>CurrentUser</code>不能为<code>null</code>，而且<code>UserName</code>不能为空；</li>
<li><code>RequiresClaims</code> - 用户必须满足声明列表中所有的条件才能获取资源；</li>
<li><code>RequiresAnyClaim</code> - 见上一条，但是只需满足任意一条；</li>
<li><code>RequiresValidatedClaims</code> - 通过自定义函数，来全部自我掌控验证流程，函数格式<code>Func&lt;IEnumerable&lt;string&gt;, bool&gt;</code>；</li>
<li><code>RequiresHttps</code> - 只允许https访问；</li>
</ul>
<p>这些都是<code>NancyModule</code>类的扩展方法，要使用它们需要添加<code>Nancy.Security</code>命名空间。</p>
<p>使用扩展方法，前面的例子可以这样写：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">SecureModule</span> <span class="o">:</span> <span class="n">NancyModule</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="n">SecureModule</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">this</span><span class="p">.</span><span class="n">RequiresAuthentication</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Your routes here</span>
<span class="p">}</span>
</pre></div>


<p>当然还可以这样写：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">SecureModule</span> <span class="o">:</span> <span class="n">NancyModule</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="n">SecureModule</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">this</span><span class="p">.</span><span class="n">RequiresHttps</span><span class="p">();</span>
        <span class="n">this</span><span class="p">.</span><span class="n">RequiresAuthentication</span><span class="p">();</span>
        <span class="n">this</span><span class="p">.</span><span class="n">RequiresClaims</span><span class="p">(</span><span class="n">new</span> <span class="p">[]</span> <span class="p">{</span> <span class="s">&quot;Admin&quot;</span> <span class="p">});</span>
    <span class="p">}</span>

    <span class="c1">// Your routes here</span>
<span class="p">}</span>
</pre></div>


<p>用户必须通过https，被授权，而且拥有Admin claim才能访问上面的路由。</p>
<h3>3. 创造你自己的安全扩展</h3>
<p>为了创造自己的安全扩展，你只需要添加扩展方法到<code>NancyModule</code>，并且绑定到<code>Before</code>管道，并检查证书。</p>
<p>比如，下面说明了<code>RequiresAuthentication</code>如何工作的：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="k">static</span> <span class="n">class</span> <span class="n">ModuleSecurity</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">RequiresAuthentication</span><span class="p">(</span><span class="n">this</span> <span class="n">NancyModule</span> <span class="n">module</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">module</span><span class="p">.</span><span class="n">Before</span><span class="p">.</span><span class="n">AddItemToEndOfPipeline</span><span class="p">(</span><span class="n">RequiresAuthentication</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">private</span> <span class="k">static</span> <span class="n">Response</span> <span class="n">RequiresAuthentication</span><span class="p">(</span><span class="n">NancyContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Response</span> <span class="n">response</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">context</span><span class="p">.</span><span class="n">CurrentUser</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span> <span class="o">||</span>
            <span class="n">String</span><span class="p">.</span><span class="n">IsNullOrWhiteSpace</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">CurrentUser</span><span class="p">.</span><span class="n">UserName</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Response</span> <span class="p">{</span> <span class="n">StatusCode</span> <span class="o">=</span> <span class="n">HttpStatusCode</span><span class="p">.</span><span class="n">Unauthorized</span> <span class="p">};</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">response</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>


<h3>4. 实现自己的验证provider</h3>
<p>实际的验证provider实现根据不同的需求变化很大，但是基本模式如下：</p>
<ol>
<li><a href="https://github.com/NancyFx/Nancy/wiki/The%20Application%20Before,%20After%20and%20OnError%20pipelines">应用管道</a>的<code>Before</code>钩子用来检查请求的证书（比如cookie, headers等等）。如果发现证书，则验证用户并授权给<code>NancyContext</code>的<code>CurrentUser</code>属性。</li>
<li><a href="https://github.com/NancyFx/Nancy/wiki/The%20before%20and%20after%20module%20hooks">模块管道</a>的<code>Before</code>钩子用来确认当前的请求是被认证的用户执行，如果不是，则拒绝并返回<code>HttpStatusCode.Unauthorized</code></li>
<li><a href="https://github.com/NancyFx/Nancy/wiki/The%20Application%20Before,%20After%20and%20OnError%20pipelines">应用管道</a>的<code>After</code>钩子用来检查请求是否因为认证失败而被丢弃，比如检查<code>HttpStatusCode.Unauthorized</code>(401)状态码。如果检测到了就帮助用户去认证，比如重定向到login表单或者使用header的帮助通知客户端。</li>
</ol>
<h3>5. 无状态认证</h3>
<p>无状态认证就是在每个请求中进行检查，根据请求的一些信息，来决定是否应该被确认为一个已认证的请求。</p>
<p>比如你检查请求来确认查询字符串的参数是否传递了api key，或者是否包含某些head， 有或者请求是否来自某些特定的ip。</p>
<p>使用无状态认证需要做下面几件事：
1. 安装<code>Nancy.Authentication.Stateless</code>包
2. 配置并开启无状态认证
3. <a href="https://github.com/NancyFx/Nancy/wiki/Authentication-overview">保护资源</a></p>
<h4>5.1 配置并开启无状态认证</h4>
<p>在bootstrapper中添加：</p>
<div class="highlight"><pre><span class="n">StatelessAuthentication</span><span class="p">.</span><span class="n">Enable</span><span class="p">(</span><span class="n">pipelines</span><span class="p">,</span> <span class="n">statelessAuthConfiguration</span><span class="p">);</span>
</pre></div>


<p>被传递到<code>StatelessAuthentication.Enable</code>方法中的<code>statelessAuthConfiguration</code>变量，是一个<code>StatelessAuthenticationConfiguration</code>类型的实例，它能够让你自定义无状态认证提供者的行为。</p>
<p>定义<code>StatelessAuthenticationConfiguration</code>类型实例的时候，需要有一个<code>Func&lt;NancyContext, IUserIdentity&gt;</code>类型的参数。这个函数用来检查请求或者context中的其他相关内容，并且在请求未通过验证时返回<code>null</code>，否则返回合适的<a href="https://github.com/NancyFx/Nancy/wiki/Authentication-overview"><code>IUserIdentity</code></a>.</p>
<h4>5.2 简单配置</h4>
<div class="highlight"><pre><span class="kd">var</span> <span class="n">configuration</span> <span class="o">=</span>
    <span class="nb">new</span> <span class="nx">StatelessAuthenticationConfiguration</span><span class="p">(</span><span class="n">ctx</span> <span class="o">=&gt;</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">ctx.Request.Query.apikey.HasValue</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="kt">null</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// This would where you authenticated the request. IUserApiMapper is</span>
        <span class="c1">// not a Nancy type.</span>
        <span class="kd">var</span> <span class="n">userValidator</span> <span class="o">=</span> 
            <span class="nx">container.Resolve</span><span class="o">&lt;</span><span class="nx">IUserApiMapper</span><span class="o">&gt;</span><span class="p">();</span>

        <span class="k">return</span> <span class="nx">userValidator.GetUserFromAccessToken</span><span class="p">(</span><span class="nx">ctx.Request.Query.apikey</span><span class="p">);</span>
    <span class="p">});</span>
</pre></div>


<h3>6. Form认证</h3>
<p>详细例子见Nancy解决方案中<code>Nancy.Demo.Authentication.Forms</code>例子</p>
<p>为了开启form认证，需要完成：</p>
<ol>
<li>安装<code>Nancy.Authentication.Forms</code>包</li>
<li>实现<code>IUserMapper</code></li>
<li>实现路由来处理login和logout</li>
<li>配置并开启Form认证</li>
</ol>
<h4>6.1 User mapper</h4>
<p>User mapper用来负责从标示符identifier映射到用户。标示符是一个令牌，被存储在认证cookie中，用来代表执行请求的用户身份，避免每次请求时输入证书。</p>
<p>使用GUID来做标示符，如果用username来做标示符容易被嗅探并攻击。GUID还很难读取，而且每个GUID都不一样，增加了嗅探的难度。</p>
<p>注意，需要知道标示符对每个用户来说都是永久的并且是唯一的。</p>
<p><code>IUserMapper</code>接口的定义：</p>
<div class="highlight"><pre><span class="k">public</span> <span class="nf">interface</span> <span class="nx">IUserMapper</span>
<span class="p">{</span>
    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Get the real username from an identifier</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="c1">/// &lt;param name=&quot;identifier&quot;&gt;User identifier&lt;/param&gt;</span>
    <span class="c1">/// &lt;param name=&quot;context&quot;&gt;The current NancyFx context&lt;/param&gt;</span>
    <span class="c1">/// &lt;returns&gt;Matching populated IUserIdentity object, or empty&lt;/returns&gt;</span>
    <span class="nx">IUserIdentity</span> <span class="nx">GetUserFromIdentifier</span><span class="p">(</span><span class="nx">Guid</span> <span class="nx">identifier</span><span class="p">,</span> <span class="nx">NancyContext</span> <span class="nx">context</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h4>6.2 修改应用，处理form认证</h4>
<p>有了<code>IUserMapper</code>后，下一步就是在不需要认证的地方添加login和logout了。</p>
<p>下面是一个模块的基础框架。请注意资源的路径和模块的名称可以使任意的：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">LoginModule</span> <span class="o">:</span> <span class="n">NancyModule</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="n">LoginModule</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Get</span><span class="p">[</span><span class="s">&quot;/login&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Called when the user visits the login page or is redirected here because</span>
            <span class="c1">// an attempt was made to access a restricted resource. It should return</span>
            <span class="c1">// the view that contains the login form</span>
        <span class="p">};</span>

        <span class="n">Get</span><span class="p">[</span><span class="s">&quot;/logout&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Called when the user clicks the sign out button in the application. Should</span>
            <span class="c1">// perform one of the Logout actions (see below)</span>
        <span class="p">};</span>

        <span class="n">Post</span><span class="p">[</span><span class="s">&quot;/login&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Called when the user submits the contents of the login form. Should</span>
            <span class="c1">// validate the user based on the posted form data, and perform one of the</span>
            <span class="c1">// Login actions (see below)</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p><code>Nancy.Authentication.Forms</code>命名空间中有一些扩展方法可供使用：</p>
<ul>
<li><code>LoginAndRedirect</code> - 登录用户并重定向用户到他们来时的url。或者也可以提供一个预留的url，用来在没有重定向url时使用。如果使用form提交，注意使用action=""，因为它会保留returnUrl原封不动。</li>
<li><code>LoginWithoutRedirect</code> - 登录用户，并且返回响应和状态码200(ok)</li>
<li><code>Login</code>会调用当前请求的<code>IsAjaxRequest</code>的扩展方法，并且如果不是Ajax调用，则执行<code>LoginAndRedirect</code>方法，否则执行<code>LoginWithoutRedirect</code>方法</li>
<li><code>LogoutAndRedirect</code> - 登出用户，并提供重定向</li>
<li><code>LogoutWithoutRedirect</code> - 登出用户并返回状态码为200(OK)的响应</li>
<li><code>Logout</code>会调用当前请求的<code>IsAjaxRequest</code>方法，如果不是ajax请求，则执行<code>LogoutAndRedirect</code>，否则执行<code>LogoutWithoutRedirect</code></li>
</ul>
<p><strong>注意1：</strong> <code>Nancy.Extensions.RequestExtensions</code>中的<code>IsAjaxRequest</code>扩展方法会检查<code>X-Requested-With</code>头，并且在其包含值<code>XMLHttpRequest</code>时返回true</p>
<p><strong>注意2：</strong> 请确认路径的定义login和logout的页面没有要求使用登录。</p>
<h4>6.3 启用form认证</h4>
<p>在bootstrapper中添加：</p>
<div class="highlight"><pre><span class="n">FormsAuthentication</span><span class="p">.</span><span class="n">Enable</span><span class="p">(</span><span class="n">pipelines</span><span class="p">,</span> <span class="n">formsAuthConfiguration</span><span class="p">);</span>
</pre></div>


<p>既可以在<code>ApplicationStartup</code>中又可以在<code>RequestStartup</code>中添加。到底在何处加，取决于<code>IUserMapper</code>，即user mapper到底是有应用级的生命周期还是请求级的生命周期。</p>
<p>传递给<code>FormsAuthentication.Enable</code>方法的<code>formsAuthConfiguration</code>变量是<code>FormsAuthenticationConfiguration</code>类型，它能让你自定义form认证提供者的行为。</p>
<p>比如，下面是一个基本的认证配置：</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="n">formsAuthConfiguration</span> <span class="o">=</span>
<span class="nb">new</span> <span class="nx">FormsAuthenticationConfiguration</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">RedirectUrl</span> <span class="o">=</span> <span class="s2">&quot;~/login&quot;</span><span class="p">,</span>
    <span class="n">UserMapper</span> <span class="o">=</span> <span class="nx">container.Resolve</span><span class="o">&lt;</span><span class="nx">IUserMapper</span><span class="o">&gt;</span><span class="p">(),</span>
<span class="p">};</span>
</pre></div>


<p>下面是一些配置项：</p>
<ul>
<li><code>RedirectingQuerystringKey</code>：默认名是<code>returnUrl</code></li>
<li><code>RedirectingUrl</code>：未认证的用户应当被重定向的url，一般是登录页面<code>~/login</code></li>
<li><code>UserMapper</code>: <code>IUserMapper</code>在认证时应该被使用</li>
<li><code>RequiresSSL</code>: SSL</li>
<li><code>DisableRedirect</code>: 遇到未认证时，是否重定向到登陆页</li>
<li><code>CryptographyConfiguration</code>: <code>CryptographyConfiguration.Default</code>与form认证cookie配合使用。<code>CryptographyConfiguration.Default</code>是默认的。</li>
</ul>
<h4>6.4 关于加密，还有一些话</h4>
<p>默认使用<code>RandomKeyGenerator</code>，这意味着每次程序启动时会产生一个新的秘钥，那么应用重启回到这认证cookie失效，在多台机器负载均衡时也会出现这种问题，别怕，看看<a href="https://github.com/NancyFx/Nancy/wiki/The%20cryptography%20helpers">加密配置</a></p>
<p>下面是一个例子：</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="n">cryptographyConfiguration</span> <span class="o">=</span> <span class="nb">new</span> <span class="nx">CryptographyConfiguration</span><span class="p">(</span>
    <span class="nb">new</span> <span class="nx">RijndaelEncryptionProvider</span><span class="p">(</span><span class="nb">new</span> <span class="nx">PassphraseKeyGenerator</span><span class="p">(</span><span class="s2">&quot;SuperSecretPass&quot;</span><span class="p">,</span> <span class="nb">new</span> <span class="nx">byte</span><span class="err">[</span><span class="cp">]</span> { 1, 2, 3, 4, 5, 6, 7, 8 })),
    new DefaultHmacProvider(new PassphraseKeyGenerator(&quot;UberSuperSecure&quot;, new byte<span class="cp">[]</span> { 1, 2, 3, 4, 5, 6, 7, 8 })));

var config = 
    new FormsAuthenticationConfiguration()
    {
        CryptographyConfiguration = cryptographyConfiguration,
        RedirectUrl = &quot;/login&quot;,
        UserMapper = container.Resolve<span class="nt">&lt;IUserMapper&gt;</span>(),
    };
</pre></div>


<h4>6.5 跟多</h4>
<ul>
<li>
<p><a href="http://www.philliphaydon.com/2012/12/forms-authentication-with-nancyfx/">Forms authentication with nancyfx</a></p>
</li>
<li>
<p><a href="http://www.philliphaydon.com/2012/12/configuring-multiple-forms-authentication-sections-with-nancyfx/">Multiple forms authentication sections</a></p>
</li>
</ul>
<h3>7. 令牌认证</h3>
<p>详细例子在Nancy解决方案中的<code>Nancy.Demo.Authentication.Token</code>中。</p>
<h4>7.1 认识Nancy的令牌认证</h4>
<p>Nancy令牌认证工程是为了多种客户端(iOS, Android, Angular SPA等等)能与统一后台Nancy应用而创建的。</p>
<h4>7.2 基本原理</h4>
<p>令牌认证与授权在下面这些需求下应运而生：</p>
<ul>
<li>没有cookie（不适所有的客户端都是浏览器）</li>
<li>避免一旦用户被认证/授权后，从后端数据存储中取回用户和权限信息</li>
<li>允许客户端应用在第一次授权后保存令牌，以便为后续请求使用</li>
<li>通过单向加密算法确保令牌没有被篡改，阻止嗅探冒充令牌攻击</li>
<li>使用有期限的可配置的key来进行令牌生成</li>
<li>使用server端的文件系统来存储私钥，这样即使应用重启也能恢复。注意：可以使用内存存储作为测试。</li>
</ul>
<h4>7.3 使用</h4>
<h5>7.3.1 Nancy配置</h5>
<p>令牌认证可以像form认证那样：</p>
<div class="highlight"><pre><span class="k">public</span> <span class="nf">class</span> <span class="nx">Bootstrapper</span> <span class="p">:</span> <span class="nx">DefaultNancyBootstrapper</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="nf">override</span> <span class="bp">void</span> <span class="nx">RequestStartup</span><span class="p">(</span><span class="nx">TinyIoCContainer</span> <span class="nx">container</span><span class="p">,</span> <span class="nx">IPipelines</span> <span class="nx">pipelines</span><span class="p">,</span> <span class="nx">NancyContext</span> <span class="nx">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nx">TokenAuthentication.Enable</span><span class="p">(</span><span class="nx">pipelines</span><span class="p">,</span> <span class="nb">new</span> <span class="nx">TokenAuthenticationConfiguration</span><span class="p">(</span><span class="nx">container.Resolve</span><span class="o">&lt;</span><span class="nx">ITokenizer</span><span class="o">&gt;</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>令牌从<code>IUserIdentity</code>和<code>NancyContext</code>中，通过实现<code>ITokenizer</code>接口产生。默认实现是<code>Tokenizer</code>，它提供了一些可配置的方法。默认情况下，它产生一个令牌包含下面部分：</p>
<ul>
<li>用户名</li>
<li>Pipe separated list of user claims</li>
<li>UTC当前时间</li>
<li>客户端的"User-Agent"头（必须）</li>
</ul>
<p>建议配置Tokenizer，使用其他附加能代表用户唯一设备的信息。</p>
<p>下面举例说明了如何初始化用户认证，并且返回生成的令牌给客户端：</p>
<div class="highlight"><pre><span class="n">public</span> <span class="n">class</span> <span class="n">AuthModule</span> <span class="o">:</span> <span class="n">NancyModule</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="n">AuthModule</span><span class="p">(</span><span class="n">ITokenizer</span> <span class="n">tokenizer</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">base</span><span class="p">(</span><span class="s">&quot;/auth&quot;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Post</span><span class="p">[</span><span class="s">&quot;/&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">=&gt;</span>
            <span class="p">{</span>
                <span class="n">var</span> <span class="n">userName</span> <span class="o">=</span> <span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="n">this</span><span class="p">.</span><span class="n">Request</span><span class="p">.</span><span class="n">Form</span><span class="p">.</span><span class="n">UserName</span><span class="p">;</span>
                <span class="n">var</span> <span class="n">password</span> <span class="o">=</span> <span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="n">this</span><span class="p">.</span><span class="n">Request</span><span class="p">.</span><span class="n">Form</span><span class="p">.</span><span class="n">Password</span><span class="p">;</span>

                <span class="n">var</span> <span class="n">userIdentity</span> <span class="o">=</span> <span class="n">UserDatabase</span><span class="p">.</span><span class="n">ValidateUser</span><span class="p">(</span><span class="n">userName</span><span class="p">,</span> <span class="n">password</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">userIdentity</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">return</span> <span class="n">HttpStatusCode</span><span class="p">.</span><span class="n">Unauthorized</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">var</span> <span class="n">token</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="p">.</span><span class="n">Tokenize</span><span class="p">(</span><span class="n">userIdentity</span><span class="p">,</span> <span class="n">Context</span><span class="p">);</span>

                <span class="k">return</span> <span class="n">new</span>
                    <span class="p">{</span>
                        <span class="n">Token</span> <span class="o">=</span> <span class="n">token</span><span class="p">,</span>
                    <span class="p">};</span>
            <span class="p">};</span>

        <span class="n">Get</span><span class="p">[</span><span class="s">&quot;/validation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_</span> <span class="o">=&gt;</span>
            <span class="p">{</span>
                <span class="n">this</span><span class="p">.</span><span class="n">RequiresAuthentication</span><span class="p">();</span>
                <span class="k">return</span> <span class="s">&quot;Yay! You are authenticated!&quot;</span><span class="p">;</span>
            <span class="p">};</span>

        <span class="n">Get</span><span class="p">[</span><span class="s">&quot;/admin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_</span> <span class="o">=&gt;</span>
        <span class="p">{</span>
            <span class="n">this</span><span class="p">.</span><span class="n">RequiresClaims</span><span class="p">(</span><span class="n">new</span><span class="p">[]</span> <span class="p">{</span> <span class="s">&quot;admin&quot;</span> <span class="p">});</span>
            <span class="k">return</span> <span class="s">&quot;Yay! You are authorized!&quot;</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h5>7.3.2 客户端配置</h5>
<p>一旦你的客户端接收到了token，那么你必须使用token来设置HTTP头：</p>
<div class="highlight"><pre><span class="n">Authorization</span><span class="o">:</span> <span class="n">Token</span> <span class="o">{</span><span class="n">your</span><span class="o">-</span><span class="n">token</span><span class="o">-</span><span class="n">goes</span><span class="o">-</span><span class="n">here</span><span class="o">}</span>
</pre></div>


<h4>8. 幕后的工作</h4>
<p>https://github.com/NancyFx/Nancy/commit/9ae0a5494bc335c3d940d730ae5d5f18c1018836</p></div>
    <footer>
<p class="meta">
  <span class="byline author vcard">
    Posted by <span class="fn">刘理想</span>
  </span>
<time datetime="2014-09-12T23:39:00" pubdate>五 12 九月 2014</time>  <span class="categories">
    <a class="category" href="./tag/nancy.html">Nancy</a>
    <a class="category" href="./tag/c.html">C#</a>
    <a class="category" href="./tag/net.html">.NET</a>
    <a class="category" href="./tag/web.html">web</a>
  </span>
</p><div class="sharing">
</div>    </footer>
  </article>

  <section>
    <h1>Comments</h1>
    <div id="DuoShuoComment" aria-live="polite">
<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="nancy-webkuang-jia.html" data-title="Nancy Web框架" data-url="./nancy-webkuang-jia.html"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"liulixiang1988blog"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
    </div>
  </section>
</div>
<aside class="sidebar">
  <section>
	  <img src="./images/avatar.jpg" alt="刘理想" width=""/> 
  </section>
  <section>
    <h1>Recent Posts</h1>
    <ul id="recent_posts">
      <li class="post">
          <a href="./shi-yong-aspnet-web-api-2-owinhe-identitylai-chuang-jian-tokenren-zheng-1.html">使用ASP.NET Web API 2、Owin和Identity来创建Token认证(1)</a>
      </li>
      <li class="post">
          <a href="./shi-yong-androidkai-fa-yue-hou-ji-fen-ying-yong-01-kai-shi.html">使用Android开发阅后即焚应用-01 开始</a>
      </li>
      <li class="post">
          <a href="./shi-yong-androidkai-fa-yi-ge-bo-ke-yue-du-qi-05-shi-yong-intentxian-shi-he-gong-xiang-bo-ke.html">使用Android开发一个博客阅读器-05 使用Intent显示和共享博客</a>
      </li>
      <li class="post">
          <a href="./shi-yong-androidkai-fa-yi-ge-bo-ke-yue-du-qi-04-zai-listzhong-zhan-xian-shu-ju.html">使用Android开发一个博客阅读器-04 在List中展现数据</a>
      </li>
      <li class="post">
          <a href="./django-sql-servershu-ju-ku-qu-dong-gen-ju-xian-you-shu-ju-ku-sheng-cheng-modelsyi-ji-shu-ju-ku-qian-yi.html">Django SQL Server数据库驱动,根据现有数据库生成models以及数据库迁移</a>
      </li>
    </ul>
  </section>
  <section>
      
    <h1>Categories</h1>
    <ul id="recent_posts">
        <li><a href="./category/android.html">Android</a></li>
        <li><a href="./category/dotnet.html">DotNet</a></li>
        <li><a href="./category/net.html">.NET</a></li>
        <li><a href="./category/python.html">Python</a></li>
        <li><a href="./category/sheng-huo.html">生活</a></li>
    </ul>
  </section>
 

  <section>
  <h1>Tags</h1>
    <a href="./tag/c.html">C#</a>,    <a href="./tag/android.html">Android</a>,    <a href="./tag/python.html">Python</a>,    <a href="./tag/life.html">life</a>,    <a href="./tag/django.html">Django</a>,    <a href="./tag/web.html">web</a>,    <a href="./tag/nancy.html">Nancy</a>,    <a href="./tag/net.html">.NET</a>,    <a href="./tag/androiyue-hou-ji-fen.html">Androi阅后即焚</a>,    <a href="./tag/androibo-ke-yue-du.html">Androi博客阅读</a>,    <a href="./tag/pelican.html">pelican</a>,    <a href="./tag/androidxue-xi-bi-ji.html">Android学习笔记</a>  </section>



  <section>
    <h1>GitHub Repos</h1>
    <ul id="gh_repos">
      <li class="loading">Status updating...</li>
    </ul>
      <a href="https://github.com/liulixiang1988">@liulixiang1988</a> on GitHub
    <script type="text/javascript">
      $.domReady(function(){
          if (!window.jXHR){
              var jxhr = document.createElement('script');
              jxhr.type = 'text/javascript';
              jxhr.src = './theme/js/jXHR.js';
              var s = document.getElementsByTagName('script')[0];
              s.parentNode.insertBefore(jxhr, s);
          }

          github.showRepos({
              user: 'liulixiang1988',
              count: 5,
              skip_forks: false,
              target: '#gh_repos'
          });
      });
    </script>
    <script src="./theme/js/github.js" type="text/javascript"> </script>
  </section>

    <section>
        <h1>Social</h1>
        <ul>
            <li><a href="http://weibo.com/liulixiang1988" target="_blank">微博</a></li>
        </ul>
    </section>
    <section>
        <h1>Blogroll</h1>
        <ul>
            <li><a href="https://github.com/liulixiang1988/" target="_blank">GitHub</a></li>
        </ul>
    </section>

</aside>    </div>
  </div>
  <footer role="contentinfo"><p>
    Copyright &copy;  2014  - 理想 -
  <span class="credit">Powered by <a href="http://getpelican.com">Pelican</a></span>
</p></footer>
</body>
</html>